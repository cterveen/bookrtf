<?php
 
 /**
 * @file
 * A  module that exports books as rtf
 */
 

 /**
 * Manually load the libraries module to get access to libraries_get_path();
 * This should not be necessary!
 */
include_once(drupal_get_path("module", "libraries") . "/libraries.module");
 
 /**
 * Load the PHP simple HTML DOM parser if not done yet
 *
 * get it here: https://simplehtmldom.sourceforge.io/
 * save it to: sites/all/libraries/simle_html_dom/
 */
include_once(libraries_get_path("simple_html_dom") . "/simple_html_dom.php");

 /**
 * Load the css parser if not done yet
 *
 * get it here: https://github.com/Schepp/CSS-Parser
 * save it to: sites/all/libraries/schepp-css-parser/
 */ 
include_once(libraries_get_path("schepp-css-parser") . "/parser.php");
 
 /**
 * Implements hook_help().
 *
 * Displays help and module information.
 *
 * @param path 
 *   Which path of the site we're using to display help
 * @param arg 
 *   Array that holds the current path as returned from arg() function
 */
 
function bookrtf_help($path, $arg) {
  switch ($path) {
    case "admin/help#bookrtf":
      return '' . t("Exports a book as rtf file.") . '';
      break;
  }
}

/**
* Implements hook_menu().
*/

function bookrtf_menu() {
  $items = array();
  $items['book/rtf/1'] = array(
     'title' => 'Download',
     'page callback' => '_bookrtf_page',
     'page arguments' => array(2),
     'access arguments' => array('access content'),
     'type' => MENU_CALLBACK,
   );
   
   $items['admin/config/bookrtf'] = array(
    'title' => 'BookRTF',
    'description' => 'Configuration for BookRTF module',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('bookrtf_form'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM);
   
   
   return $items;
}

/** 
 * Implements hook_form
 */

function bookrtf_form($form, &$form_state) {

  /**
  * Options for the module (need a lot of that)
  *
  * - Custom title
  * - Custom filename
  * - Custom front_page
  * - Show table of contents
  * - Show index
  * - Download page text.
  */
  
  $form['bookrtf_title'] = array(
    '#type' => 'textfield',
    '#title' => t('Book title'),
    '#default_value' => variable_get('bookrtf_title', variable_get('site_name', "Default site name")),
    '#size' => 20,
    '#maxlength' => 20,
    '#description' => t('The title to use for the book'),
    '#required' => TRUE,
  );
  
  $form['bookrtf_filename'] = array(
    '#type' => 'textfield',
    '#title' => t('File name'),
    '#default_value' => variable_get('bookrtf_filename', "download.rtf"),
    '#size' => 20,
    '#maxlength' => 20,
    '#description' => t('The filename for the download'),
    '#required' => FALSE,
  );
  
  
  $form['bookrtf_front'] = array(
    '#type' => 'checkbox',
    '#title' => 'Include custom frontpage',
    '#default_value' => variable_get('bookrtf_front', 1),
    '#description' => t('The front page can be defined below'),);
  
  $form['bookrtf_flyleaf'] = array(
    '#type' => 'checkbox',
    '#title' => 'Include flyleaf',
    '#default_value' => variable_get('bookrtf_flyleaf', 1));
  
  $form['bookrtf_toc'] = array (
    '#type' => 'checkbox',
    '#title' => 'Include table of contents',
    '#default_value' => variable_get('bookrtf_toc', 1));
    
  $form['bookrtf_index'] = array(
    '#type' => 'checkbox',
    '#title' => 'Include index',
    '#default_value' => variable_get('bookrtf_index', 0));
    
  $form['bookrtf_header_left'] = array(
    '#type' => 'select',
    '#title' => t('Left header'),
    '#options' => array(
      0 => "Nothing",
      1 => "Book title",
      2 => "Chapter title",
      3 => "Page number"),
    '#default_value' => variable_get('bookrtf_header_left', 0));
    
  $form['bookrtf_header_right'] = array(
    '#type' => 'select',
    '#title' => t('Right header'),
    '#options' => array(
      0 => "Nothing",
      1 => "Book title",
      2 => "Chapter title",
      3 => "Page number"),
    '#default_value' => variable_get('bookrtf_header_right', 0));  
    
  $form['bookrtf_footer_left'] = array(
    '#type' => 'select',
    '#title' => t('Left footer'),
    '#options' => array(
      0 => "Nothing",
      1 => "Book title",
      2 => "Chapter title",
      3 => "Page number"),
    '#default_value' => variable_get('bookrtf_footer_left', 0));  
   
  $form['bookrtf_footer_right'] = array(
    '#type' => 'select',
    '#title' => t('Right footer'),
    '#options' => array(
      0 => "Nothing",
      1 => "Book title",
      2 => "Chapter title",
      3 => "Page number"),
    '#default_value' => variable_get('bookrtf_footer_right', 0));   
    
  $bookrtf_front_page = variable_get('bookrtf_front_page', array('value' => '<h3>'.variable_get('bookrtf_title', variable_get('site_name', "Default site name")).'</h3>', 'format' => 'full_html'));
  
  $form['bookrtf_front_page'] = array(
    '#type' => 'text_format',
    '#format' => $bookrtf_front_page['format'],
    '#title' => 'Custom frontpage',
    '#default_value' => $bookrtf_front_page['value'],
    '#description' => t('A custom frontpage for your book'));
      
  $form['bookrtf_download_title'] = array(
    '#type' => 'textfield',
    '#title' => t('Title of download page'),
    '#default_value' => variable_get('bookrtf_download_title', "Download"),
    '#size' => 20,
    '#maxlength' => 20,
    '#description' => t('The title to use for the download page'),
    '#required' => TRUE,);    
    
  $bookrtf_download_page = variable_get('bookrtf_download_page', array('value' => '<p><a href = "' . file_create_url('public://' . variable_get('bookrtf_filename', "download.rtf")) . '">Download ' . variable_get('bookrtf_filename', "download.rtf") . '</p>', 'format' => 'full_html'));
  $form['bookrtf_download_page'] = array(
    '#type' => 'text_format',
    '#format' => $bookrtf_download_page['format'],
    '#title' => t('Contents of download page'),
    '#default_value' => $bookrtf_download_page['value'],
    '#description' => t('The text of the download page'),
    '#required' => TRUE);

  return system_settings_form($form);
}

/**
 * Implements validation from the Form API.
 * 
 * @param $form
 *   A structured array containing the elements and properties of the form.
 * @param $form_state
 *   An array that stores information about the form's current state 
 *   during processing.
 */
 
function bookrtf_form_validate($form, &$form_state){
  $filename = $form_state['values']['bookrtf_filename'];
  if (strlen($filename) <= 4 | substr($filename, -4) != ".rtf") {
    form_set_error('bookrtf_filename', t('You must enter a valid filename that ends with .rtf'));
  }
}

 /**
 * Get the contents from print and, convert to RTF, save as file and show a download page.
 */

function _bookrtf_page($nid) {
  if (user_access('access content')) {
    $node = node_load($nid);
    if (isset($node->book)) {
      global $base_url;
      
      $tree = book_menu_subtree_data($node->book);        
      $content = bookrtf_index_traverse($tree);
      $content = bookrtf_convert($content, $base_url);
      
      file_put_contents(file_destination("public://" . variable_get('bookrtf_filename', "download.rtf"), FILE_EXISTS_REPLACE), $content);
      
      $bookrtf_download_page = variable_get('bookrtf_download_page', array('value' => '<p><a href = "' . file_create_url('public://' . variable_get('bookrtf_filename', "download.rtf")) . '">Download ' . variable_get('bookrtf_filename', "download.rtf") . '</p>', 'format' => 'full_html'));
      
      $page_array['index'] = array(
        '#title' => t(variable_get('bookrtf_download_title', "Download")),
        '#markup' => t($bookrtf_download_page['value']),
      );
   
      return $page_array;
    }
    else {
      drupal_not_found();
    }
  }
  else {
    drupal_access_denied();
  }  
}

 /**
 * Copy of book_index_traverse
 */

function bookrtf_index_traverse($tree) {
    $output = '';    
    
    foreach ($tree as $data) {
      // Note- access checking is already performed when building the tree.
      if ($node = node_load($data['link']['nid'], FALSE)) {
        $children = '';

        if ($data['below']) {
          $children = bookrtf_index_traverse($data['below']);
        }
      }
      
      $output .= book_node_export($node, $children);      
      
    }
    
    return $output;  
}

 /**
 * The engine, convert HTML output to RTF and add some shiny touches.
 */

function bookrtf_convert($content, $base_url) {
  global $bookrtf_firstpage;
  $bookrtf_firstpage = 1;
  // put some html tags around it so we can push it into the html converter.
  $content = "<html><body>" . $content . "</body></html>";
  
  // CLEAN UP spaces after newlines.
  $content = preg_replace("|\s+([\r\n]+)\s+|", "$1", $content);
  
  // style
  global $bookrtf_css;
  global $bookrtf_fonttbl;
  $css = array("main" => array());
  
  foreach (array(drupal_get_path('module', "BookRTF") . "/rtf.css", drupal_get_path('theme', $GLOBALS['theme']) . "/css/rtf.css") as $css_file) {
    if (is_file($css_file)) {
      $css_parser = new CssParser();
      $css_parser->load_files($css_file);
      $css_parser->parse();
      $css = $css_parser->parsed;
      
      foreach (array_keys($css['main']) as $selector) {
        foreach(array_keys($css['main'][$selector]) as $property) {
          $bookrtf_css[$selector][$property] = $css['main'][$selector][$property];
        }
      }
    }  
  }    
  
  // get the default font from body
  if (array_key_exists("body", $bookrtf_css)) {
    if (array_key_exists("font-family", $bookrtf_css["body"])) {
      preg_match("|^([^,]+),?|", $bookrtf_css["body"]["font-family"], $r);
      $font = trim($r[1]);
      $font = preg_replace("|\"|", "", $font);
      $bookrtf_fonttbl[$font] = 0;
    }
  }

  $tags = array_keys($css["main"]);
  
  $book_title = variable_get('bookrtf_title', variable_get('site_name', "Default site name"));
  
  /** 
  * Start with the content.
  * This is done first because the font table might be appended during the
  * conversion process.
  *
  * The tough work is going to be done by bookrtf_traverse. 
  */
  
  $html = str_get_html($content);
  $elements = $html->find('html');
  bookrtf_traverse($elements, $base_url);
  
  // dumb the new code back to $content
  $content = $html;  
  
  // strip all remaining tags
  $content = strip_tags($content);
    
  /**
   * HEADER
   * - Front page
   * - Flyleaf containing URL and date of download
   * - Table of contents
   * - Start of first page
   */   
    
  $header = "\\rtf1\\ansi\r\n";
  $header .= "\\deff0 {\\fonttbl ";
  if (!is_array($bookrtf_fonttbl)) {
    $header .= "{\\f0 Calibri;}";
  }
  else {
    foreach (array_keys($bookrtf_fonttbl) as $font) {
      $header .= "{\\f" . $bookrtf_fonttbl[$font] . " " . $font . ";}";
    }
  }
  $header .= "}\r\n";
  $header .= "\\vertdoc\\paperh16834\\paperw11909\r\n";
  $header .= "\\fet0\\facingp\\ftnbj\\ftnrstpg\r\n";
  $header .= "\\plain\r\n";
  
  if (variable_get('bookrtf_front', 1)) {
    $bookrtf_firstpage = 0;
    $bookrtf_front_page = variable_get('bookrtf_front_page', array('value' => '<h3>'.$book_title.'</h3>', 'format' => 'full_html'));
    $bookrtf_front_page["value"] = "<html><body><h3>" . $bookrtf_front_page["value"] . "</body></html>";
    $title_html = str_get_html($bookrtf_front_page["value"]);
    $elements = $title_html->find('html');
    bookrtf_traverse($elements, $base_url);
    $title_html = strip_tags($title_html);
    $header .= $title_html;
  }  

  // flyleaf  
  if (variable_get('bookrtf_flyleaf', 1)) {
    if ($bookrtf_firstpage == 1) {
      $bookrtf_firstpage = 0;
    }
    else {
      $header .= "\\sect\\sftnrstpg\r\n";
    }
    $header .= "{\\pard\\qc";
    $header .= "{\\b " . $book_title . "}\\line\r\n";
    if (isset($base_url)) {
      $header .= $base_url;
    }
    $header .= "\\line\r\n\\line\r\n";
    $date = new DateTime();
    $header .= "Gegenereerd: " . date_format($date, "d-m-Y") . " \\par}\r\n";
  }
  
  $toc = $html->find("h1");
  // table of contents
  if (variable_get('bookrtf_toc', 1)) {
    if ($bookrtf_firstpage == 1) {
      $bookrtf_firstpage = 0;
    }
    else {
      $header .= "\\sect\\sftnrstpg\r\n";
    }
    
    $header .= "{\\pard " .  bookrtf_get_style($toc[0]) . "Inhoud\r\n";
    $header .= "\\par}\r\n{\\pard {";
        
    // remove the first title as this should be the title of the book and does not belong in the toc.
    $book_title_element = array_shift($toc);
    $book_title_element->outertext = "";
    foreach ($toc as $e) {
      // Assume title starts with the chapternumber
      $title = $e->innertext;
      preg_match("|^(\d+)\.\s|", $title, $match);
      $chapter = $match[1];
    
      $header .= "\\trowd";
      $header .= "\\cellx7000 \\cellx8309\r\n"; 
      $header .= "\\intbl\\pard " .$title . "\\cell";
      $header .= "\\qr{\\field{\*\\fldinst PAGEREF chapter".$chapter."}}\\cell\\row\r\n";
    }
  
    if (variable_get('bookrtf_index', 0)) {
      $header .= "\\trowd";
      $header .= "\\cellx7000 \\cellx8309\r\n"; 
      $header .= "\\intbl\\pard Index\\cell";
      $header .= "\\qr{\\field{\*\\fldinst PAGEREF chapterIndex}}\\cell\\row\r\n";
    }
    $header .= "}\\par}\r\n";
  }
  
  /**
   *Footer
   * - index
   */
   
   $footer = "";
  
  if (variable_get('bookrtf_index', 0)) {
    $footer .= "\r\n\\page\r\n\\sect\r\n";
    $footer .= "{\\headerl\\pard\\ql {\b ".$book_title."}\\par}\r\n";
    $footer .= "{\\headerr\\pard\\qr Index\\par}\r\n";
    $footer .= "{\\footerr\\pard\\qr \\chpgn \\par}\r\n";
    $footer .= "{\\footerl\\pard\\ql \\chpgn \\par}\r\n";
    $footer .= "{\\pard " . bookrtf_get_style($toc[0]);
    $footer .= "{\\*\\bkmkstart chapterIndex}{\\*\\bkmkend chapterIndex}Index";
    $footer .= "\\par}\r\n";
    $footer .= "\\sect \\sbknone \\cols2\r\n";  
  
    $anchors = $html->find('a[name]');
    $terms = array();
    foreach ($anchors as $a) {
      $label = $a->name;
      if (preg_match("|^index|", $label)) {
        $label = substr($label, 5);
        array_push($terms, $label);
      }
    }
    sort($terms);
  
    $cur_initial = "";
  
    global $index_id;
    $index_id = array();
    $i = 0;
  
    foreach ($terms as $t) {
      if (!isset($index_id[$t])) {
        $index_id[$t] = $i;
        $anchor = "index-" . $i ; 
        $i++;
  
        $initial = substr($t, 0, 1);
        if (is_numeric($initial)) {
          $initial = "#";
        }
        if ($initial != $cur_initial) {
          if ($cur_initial != "") {
            $footer .= "\\par}\r\n";
          }
          $footer .= "{\\pard\\fs28{\\b " . $initial . "\\b}\\par}\r\n";
          $footer .= "{\\pard\\ql ";
          $cur_initial = $initial;
        }
        $footer .= $t . " {\\field{\*\\fldinst PAGEREF ".$anchor."}}\\line\r\n";
      }
    }
    $footer .= "\\par}\r\n";
  }
  
  // FINAL DOCUMENT
  $content = "{" . $header . "\r\n" . $content . "\r\n" . $footer . "}";
  
  // remove whitespaces around newlines
  $content = preg_replace("|\s+([\r\n]+)\s+|", "$1", $content);
  // TODO: sometimes an extra space is added in table cells that contain lists, find out why
  $content = preg_replace_callback("|\\intbl{([^\s]+)\s+{|", function($m) { return "intbl{". $m[1] ."{";}, $content);
  
  // SPECIAL CHARACTERS
  // extended ascii
  $content = preg_replace("|€|", "\'80", $content);
  // $content = preg_replace("|foo|", "\'81", $content);
  $content = preg_replace("|‚|", "\'82", $content);
  $content = preg_replace("|ƒ|", "\'83", $content);
  $content = preg_replace("|„|", "\'84", $content);
  $content = preg_replace("|…|", "\'85", $content);
  $content = preg_replace("|†|", "\'86", $content);
  $content = preg_replace("|‡|", "\'87", $content);
  $content = preg_replace("|ˆ|", "\'88", $content);
  $content = preg_replace("|‰|", "\'89", $content);
  $content = preg_replace("|Š|", "\'8a", $content);
  $content = preg_replace("|‹|", "\'8b", $content);
  $content = preg_replace("|Œ|", "\'8c", $content);
  // $content = preg_replace("|foo|", "\'8d", $content);
  $content = preg_replace("|Ž|", "\'8e", $content);
  // $content = preg_replace("|foo|", "\'8f", $content);
  $content = preg_replace("|‘|", "\'91", $content);
  $content = preg_replace("|’|", "\'92", $content);
  $content = preg_replace("|´|", "\'b4", $content);
  $content = preg_replace("|“|", "\'93", $content);
  $content = preg_replace("|”|", "\'94", $content);
  $content = preg_replace("|•|", "\'95", $content);
  $content = preg_replace("|–|", "\'96", $content);
  $content = preg_replace("|–|", "\'97", $content);
  $content = preg_replace("|˜|", "\'98", $content);
  $content = preg_replace("|™|", "\'99", $content);
  $content = preg_replace("|š|", "\'9a", $content);
  $content = preg_replace("|›|", "\'9b", $content);
  $content = preg_replace("|œ|", "\'9c", $content);
  // $content = preg_replace("|foo|", "\'9d", $content);
  $content = preg_replace("|ž|", "\'9e", $content);
  $content = preg_replace("|Ÿ|", "\'9f", $content);
  // $content = preg_replace("|foo|", "\'a0", $content);
  $content = preg_replace("|¡|", "\'a1", $content);
  $content = preg_replace("|¢|", "\'a2", $content);
  $content = preg_replace("|£|", "\'a3", $content);
  $content = preg_replace("|¤|", "\'a4", $content);
  $content = preg_replace("|¥|", "\'a5", $content);
  $content = preg_replace("|¦|", "\'a6", $content);
  $content = preg_replace("|§|", "\'a7", $content);
  $content = preg_replace("|¨|", "\'a8", $content);
  $content = preg_replace("|©|", "\'a9", $content);
  $content = preg_replace("|ª|", "\'aa", $content);
  $content = preg_replace("|«|", "\'ab", $content);
  $content = preg_replace("|¬|", "\'ac", $content);
  // $content = preg_replace("|foo|", "\'ad", $content); // Should be soft hyphen
  $content = preg_replace("|®|", "\'ae", $content);
  $content = preg_replace("|¯|", "\'af", $content);
  $content = preg_replace("|°|", "\'b0", $content);
  $content = preg_replace("|±|", "\'b1", $content);
  $content = preg_replace("|²|", "\'b2", $content);
  $content = preg_replace("|³|", "\'b3", $content);
  $content = preg_replace("|´|", "\'b4", $content);
  $content = preg_replace("|µ|", "\'b5", $content);
  $content = preg_replace("|¶|", "\'b6", $content);
  $content = preg_replace("|·|", "\'b7", $content);
  $content = preg_replace("|¸|", "\'b8", $content);
  $content = preg_replace("|¹|", "\'b9", $content);
  $content = preg_replace("|º|", "\'ba", $content);
  $content = preg_replace("|»|", "\'bb", $content);
  $content = preg_replace("|¼|", "\'bc", $content);
  $content = preg_replace("|½|", "\'bd", $content);
  $content = preg_replace("|¾|", "\'be", $content);
  $content = preg_replace("|¿|", "\'bf", $content);
  $content = preg_replace("|À|", "\'c0", $content);
  $content = preg_replace("|Á|", "\'c1", $content);
  $content = preg_replace("|Â|", "\'c2", $content);
  $content = preg_replace("|Ã|", "\'c3", $content);
  $content = preg_replace("|Ä|", "\'c4", $content);
  $content = preg_replace("|Å|", "\'c5", $content);
  $content = preg_replace("|Æ|", "\'c6", $content);
  $content = preg_replace("|Ç|", "\'c7", $content);
  $content = preg_replace("|È|", "\'c8", $content);
  $content = preg_replace("|É|", "\'c9", $content);
  $content = preg_replace("|Ê|", "\'ca", $content);
  $content = preg_replace("|Ë|", "\'cb", $content);
  $content = preg_replace("|Ì|", "\'cc", $content);
  $content = preg_replace("|Í|", "\'cd", $content);
  $content = preg_replace("|Î|", "\'ce", $content);
  $content = preg_replace("|Ï|", "\'cf", $content);
  $content = preg_replace("|Ð|", "\'d0", $content);
  $content = preg_replace("|Ñ|", "\'d1", $content);
  $content = preg_replace("|Ò|", "\'d2", $content);
  $content = preg_replace("|Ó|", "\'d3", $content);
  $content = preg_replace("|Ô|", "\'d4", $content);
  $content = preg_replace("|Õ|", "\'d5", $content);
  $content = preg_replace("|Ö|", "\'d6", $content);
  $content = preg_replace("|×|", "\'d7", $content);
  $content = preg_replace("|Ø|", "\'d8", $content);
  $content = preg_replace("|Ù|", "\'d9", $content);
  $content = preg_replace("|Ú|", "\'da", $content);
  $content = preg_replace("|Û|", "\'db", $content);
  $content = preg_replace("|Ü|", "\'dc", $content);
  $content = preg_replace("|Ý|", "\'dd", $content);
  $content = preg_replace("|Þ|", "\'de", $content);
  $content = preg_replace("|ß|", "\'df", $content);
  $content = preg_replace("|à|", "\'e0", $content);
  $content = preg_replace("|á|", "\'e1", $content);
  $content = preg_replace("|â|", "\'e2", $content);
  $content = preg_replace("|ã|", "\'e3", $content);
  $content = preg_replace("|ä|", "\'e4", $content);
  $content = preg_replace("|å|", "\'e5", $content);
  $content = preg_replace("|æ|", "\'e6", $content);
  $content = preg_replace("|ç|", "\'e7", $content);
  $content = preg_replace("|è|", "\'e8", $content);
  $content = preg_replace("|é|", "\'e9", $content);
  $content = preg_replace("|ê|", "\'ea", $content);
  $content = preg_replace("|ë|", "\'eb", $content);
  $content = preg_replace("|ì|", "\'ec", $content);
  $content = preg_replace("|í|", "\'ed", $content);
  $content = preg_replace("|î|", "\'ee", $content);
  $content = preg_replace("|ï|", "\'ef", $content);
  $content = preg_replace("|ð|", "\'f0", $content);
  $content = preg_replace("|ñ|", "\'f1", $content);
  $content = preg_replace("|ò|", "\'f2", $content);
  $content = preg_replace("|ó|", "\'f3", $content);
  $content = preg_replace("|ô|", "\'f4", $content);
  $content = preg_replace("|õ|", "\'f5", $content);
  $content = preg_replace("|ö|", "\'f6", $content);
  $content = preg_replace("|÷|", "\'f7", $content);
  $content = preg_replace("|ø|", "\'f8", $content);
  $content = preg_replace("|ù|", "\'f9", $content);
  $content = preg_replace("|ú|", "\'fa", $content);
  $content = preg_replace("|û|", "\'fb", $content);
  $content = preg_replace("|ü|", "\'fc", $content);
  $content = preg_replace("|ý|", "\'fd", $content);
  $content = preg_replace("|þ|", "\'fe", $content);
  $content = preg_replace("|ÿ|", "\'ff", $content);

  // html
  $content = preg_replace("|&amp;|", "&", $content);
  $content = preg_replace("|&deg;|", "\'b0", $content);
  $content = preg_replace("|&gt;|", ">", $content);
  $content = preg_replace("|&lt;|", "<", $content);
  $content = preg_replace("|&nbsp;|", " ", $content);
  $content = preg_replace("|&#039;|", "'", $content);

  // non breaking space
  $content = preg_replace("|\x{C2}\x{A0}|", " ", $content);

  return $content;
}

/**
 * HTML parsers may not spawn demons but if you use them to replace HTML tags
 * by RTF code they do attract gremlins as the parser gets in trouble with
 * nested tags (which occur a lot in HTML). Probably the parser is losing it's
 * structure. This is solved by going through the tree and start replacing tags
 * at the branches working up to the main stem.
 *
 * @param elements 
 *   the basic $elements from which to start
 * @param base_url 
 *   The base URL of the site, needed to convert links.
 */
 
function bookrtf_traverse ($elements, $base_url) {
  global $bookrtf_css;
  
  foreach ($elements as $e) {
    if ($e->first_child()) {
      $children = $e->children();
      bookrtf_traverse($children, $base_url);
    }
    
    // no children anymore --> start changing tags
    $tag = $e->tag;
    
    switch($tag) {
      case 'a':
        // this could be either links or anchors
        if ($e->href) {
          // link --> replace with footnote
          $url = $e->href;
          $title = $e->innertext;
          
          // no use to add a footnote if the link and label are the same.
          if (preg_match("|^(https?://)?(mailto:)?" . $title . "/?$|", $url)) {
            $e->outertext = $title;
          }
          else {
            $e->outertext = $title . "{\\footnote \\pard {\\up6 \\chftn} " . $url . "}"; 
          }          
        }
        else if ($e->name) {
         if (preg_match("|^index|", $e->name)) {
           $label = substr($e->name, 5);
           global $index_id;
           $anchor = "index-" . $index_id[$label]; 
           $e->outertext = "{\\*\\bkmkstart ".$anchor."}{\\*\\bkmkend ".$anchor."}";
          }
        }
        break;
      case 'br':
        $e->outertext = "\\tab\\line\r\n";
        break;
      case 'h1':
        // start of a new chapter --> new page, right header contains chapter
        // title, bookmark for the table of contents
        $title = $e->innertext;
                
        global $bookrtf_firstpage;
        $rtf = "";
        if ($bookrtf_firstpage == 1 & variable_get('bookrtf_front', 1) == 0 & variable_get('bookrtf_flyleaf', 1) == 0 & variable_get('bookrtf_toc', 1) == 0) {
          $bookrtf_firstpage = 0;
        }
        else {
          $rtf .= "\\sect\\sftnrstpg\r\n";
        }
        
        switch(variable_get('bookrtf_header_left', 0)) {
          case 0:
            break;
          case 1:
            $rtf .= "{\\headerl\\pard ".bookrtf_css2rtf($bookrtf_css[".header-left"]) . variable_get('bookrtf_title', variable_get('site_name', "Default site name")) . "\\par}\r\n";
            break;
          case 2:
            $rtf .= "{\\headerl\\pard ".bookrtf_css2rtf($bookrtf_css[".header-left"]). $title . "\\par}\r\n";
            break;
          case 3:  
            $rtf .= "{\\headerl\\pard ".bookrtf_css2rtf($bookrtf_css[".header-left"])."\\chpgn \\par}\r\n";
            break;
        }
        
        switch(variable_get('bookrtf_header_right', 0)) {
          case 0:
            break;
          case 1:
            $rtf .= "{\\headerr\\pard ".bookrtf_css2rtf($bookrtf_css[".header-right"]) . variable_get('bookrtf_title', variable_get('site_name', "Default site name")) . "\\par}\r\n";
            break;
          case 2:
            $rtf .= "{\\headerr\\pard ".bookrtf_css2rtf($bookrtf_css[".header-right"]). $title . "\\par}\r\n";
            break;
          case 3:  
            $rtf .= "{\\headerr\\pard ".bookrtf_css2rtf($bookrtf_css[".header-right"])."\\chpgn \\par}\r\n";
            break;
        }
        
        switch(variable_get('bookrtf_footer_left', 0)) {
          case 0:
            break;
          case 1:
            $rtf .= "{\\footerl\\pard ".bookrtf_css2rtf($bookrtf_css[".footer-left"]) . variable_get('bookrtf_title', variable_get('site_name', "Default site name")) . "\\par}\r\n";
            break;
          case 2:
            $rtf .= "{\\footerl\\pard ".bookrtf_css2rtf($bookrtf_css[".footer-left"]). $title . "\\par}\r\n";
            break;
          case 3:  
            $rtf .= "{\\footerl\\pard ".bookrtf_css2rtf($bookrtf_css[".footer-left"])."\\chpgn \\par}\r\n";
            break;
        }
        
        switch(variable_get('bookrtf_footer_right', 0)) {
          case 0:
            break;
          case 1:
            $rtf .= "{\\footerr\\pard ".bookrtf_css2rtf($bookrtf_css[".footer-right"]) . variable_get('bookrtf_title', variable_get('site_name', "Default site name")) . "\\par}\r\n";
            break;
          case 2:
            $rtf .= "{\\footerr\\pard ".bookrtf_css2rtf($bookrtf_css[".footer-right"]). $title . "\\par}\r\n";
            break;
          case 3:  
            $rtf .= "{\\footerr\\pard ".bookrtf_css2rtf($bookrtf_css[".footer-right"])."\\chpgn \\par}\r\n";
            break;
        }          
          

        // if the chapter starts with a number it should be in the index, add a bookmark for it
        if (preg_match("|^(\d+)\.\s|", $title, $match)) {
          $chapter = $match[1];
          $rtf .= "{\\*\\bkmkstart chapter".$chapter."}{\\*\\bkmkend chapter".$chapter."}\r\n";
        }
        $rtf .= "{\\pard " . bookrtf_get_style($e) . $title . "\\par}\r\n";
        
        $e->outertext = $rtf;
        break;
      case 'h2':
        $e->outertext = "{\\pard " . bookrtf_get_style($e) . $e->innertext . "\\par}\r\n";
        break;
      case 'h3': 
        $e->outertext = "{\\pard " . bookrtf_get_style($e) . $e->innertext . "\\par}\r\n";     
        break;
      case 'i': 
        $e->outertext = "{\\i " . $e->innertext . "}";
        break;
      case 'img':
        $url = $e->src;
        
        // assume relative url
        if (isset($base_url) & substr($url, 0, 4) != "http") {
          $url = $base_url . $url;
        }
        
        $string = file_get_contents($url);
        
        $img = imagecreatefromstring($string);
        
        $width = imagesx($img);
        $height = imagesy($img);
        $ratio = $width/$height;
        
        // asume full page width A4 - margins = 9028 - XX  = 8309 twips
        $picwidth = 8309;
        $picheight = round($picwidth / $ratio);
        $scalex = 100;
        $scaley = 100;

        $rtf = "{\\pard{\\pict\\picw".$width."\\pich".$height."\\picwgoal".$picwidth."\\pichgoal".$picheight."\\picscalex".$scalex."\\picscaley".$scaley;
    
        // set image type (jpg or png supported)
        if (substr($url, -4) == ".png") {
          $rtf .= "\pngblip\r\n";
        }
        else if (substr($url, -4) == ".jpg" or substr($url, -5) == ".jpeg") {
          $rtf .= "\jpegblip\r\n";
        }

        $hex = bin2hex($string);
        $hex = wordwrap($hex, 80, "\r\n", TRUE);
        
        $rtf .= $hex;
        $rtf .= "\r\n}\\par}\r\n";
        
        $e->outertext = $rtf;
        break;
      case 'li':
        /**
         * This might be a bit dirty but as I'm not going to make elaborate
         * list structures I feel confident working from li backwards and
         * strip out the list-tags later.
         */
         
        $level = 0;
        $type = "ul";
        $number = 1;
        $last = 1;
        
        // Type, level
        $p = $e->parent();
        while($p) {
          if ($p->tag == "ul" | $p->tag == "ol") {
            if ($level == 0) {
              $type = $p->tag;
            }
            $level++;
          }
          $p = $p->parent();
        }
        // Item number
        $s = $e->prev_sibling();
        while($s) {
          if ($s->tag == "li") {
            $number++;
          }
          $s = $s->prev_sibling();
        }
        // Last item?
        $s = $e->next_sibling();
        while($s) {
          if ($s->tag == "li") {
            $last = 0;
            break;
          }
          $s = $s->next_sibling();
        }
        
        $rtf = "";
        // if the first item of a nested list close the current paragraph.
        // TODO: might want to check if the list is inside a paragraph and do
        // that anyway
        if ($level > 1 & $number == 1) {
          $rtf .= "\\par}\r\n";
        }
        $rtf .= "{\\pard " . bookrtf_get_style($e);
        
        $firstindent = -360;
        $lineindent = 720 * $level;
        
        $rtf .= "\\fi" . $firstindent . "\\li". $lineindent;
        if ($type == "ul") {
          $rtf .= "\\bullet\\tab ";
        }
        else {
          $rtf .= " " . $array['id'] . ".\\tab ";
        }
        $rtf .= $e->innertext;
        
        // finish the paragraph unless it's the last item in a nested list
        // TODO this will give trouble if there's tekst after the nested list.
        // This text will be included in the last item of the nested list at
        // the moment.        
        if ($last != 1 | $level == 1) {
          $rtf .= "\\par}\r\n";
        }
        if ($level == 1 & $last == 1) {
          // add some empty space after the list
          // TODO this creates an empty line, would be nicer if I could make a configurable height.
          $rtf .= "\r\n{\\pard\\sa0\\par}\r\n"; 
        }
        $e->outertext = $rtf;
        break;
      case 'p':
        $e->outertext = "{\\pard " . bookrtf_get_style($e) . $e->innertext . "\\par}\r\n";
        break;
      case 'strong': 
        $e->outertext = "{\\b " . $e->innertext . "}";
        break;
      case 'sub':
        $e->outertext = "{\\sub " . $e->innertext . "}";
        break;
      case 'sup': 
        $e->outertext = "{\\super " . $e->innertext . "}";
        break;
      case 'tbody':
        /**
         * Tables are a little bit more complicated than lists. I do not feel
         * confident working backwards from cells. Better to store the whole
         * table and than put it down again.
         */
         
        $width_in_twips = 8309;
        $width_in_pixels = 600;
        $num_rows = 0;
        $num_cols = 0;
        $table;
        $colwidth = array();        

        // retrieve table contents and some required specifications
        $rows = $e->children();
        foreach ($rows as $r) {
          if ($r->tag != "tr") {
            continue;
          }
          $num_rows++;
          $cells = $r->children();
          $cur_cols = 0;
          foreach ($cells as $c) {
            if ($c->tag != 'td' & $c->tag != 'th') {
              continue;
            }
            $cur_cols++;
            $table[$num_rows][$cur_cols]['element'] = $c;
            $table[$num_rows][$cur_cols]['innertext'] = $c->innertext;
            $table[$num_rows][$cur_cols]['col'] = $cur_cols;
            if ($c->colspan) {
              $table[$num_rows][$cur_cols]['colspan'] = $c->colspan;
            }
            else {
              $table[$num_rows][$cur_cols]['colspan'] = 1;
            }
            
            // Does using regexp for css also spawn demons?
            if ($c->style) {
              $style = array();
              preg_match_all("/([\w\-]+):\s([\w\s\-]+);?/", $c->style, $matches);
              
              for ($pid = 0; $pid < count($matches[0]); $pid++) {
                $style[$matches[1][$pid]] = $matches[2][$pid];
              }
              
              if(array_key_exists("width", $style)) {
                // asume width in pixels -> make percentage.
                if (substr($style['width'], -2) == "px") {
                  $width = substr($style['width'], 0, -2);
                  $colwidth[$cur_cols] = $width / $width_in_pixels;
                }                
              }
            }
            
            // correct cur_cols for colspan.
            $cur_cols += $table[$num_rows][$cur_cols]['colspan']-1;
          }
          if ($cur_cols > $num_cols) {
            $num_cols = $cur_cols;
          }
        }
        
        // some complicated stuff to calculate column widths
        $colright = array();
        $widthdefined = 0;
        $auto = 0;
        for ($col = 1; $col <= $num_cols; $col++) {
          if (array_key_exists($col, $colwidth)) {
            $widthdefined += $colwidth[$col];
          }
          else {
            $auto++;
          }
        }
        $autowidth = (1 - $widthdefined)/$auto;
        
        $colleft = 0;
        for ($col = 1; $col <= $num_cols; $col++) {
          if (array_key_exists($col, $colwidth)) {
            $colleft += $colwidth[$col];
          }
          else {
            $colleft += $autowidth;
          }
          $colright[$col] = $colleft;
        }
        
        // now we have the info start building it up again
        $rtf = "{";
        foreach ($table as $row) {
          $rtf .= "\\trowd";
          foreach ($row as $cell) {
            $rtf .= "\\cellx";
            $rtf .= floor($width_in_twips * $colright[$cell['col']+$cell['colspan']-1]);
          }
          foreach ($row as $cell) {
            $rtf .= "\\intbl{" . bookrtf_get_style($cell['element']) . $cell['innertext'] . "}\\cell\r\n";
          }
          $rtf .= "\\row\r\n";
        }
        $rtf .= "}\r\n{\\pard\\sa0\\par}\r\n";
          
        $e->outertext = $rtf;
        break;
      case 'title':
        $e->outertext = "";
        break;
      case 'u':
        $e->outertext = "{\\ul " . $e->innertext . "}";
        break;
    }
  }
}

/**
 * Get the appropriate style for an HTML element and return string of rtf style
 * commands.
 *
 * @param e 
 *   an element from the html table
 */

function bookrtf_get_style($e) {
  global $bookrtf_css;
  
  // most of these aren't used
  $css_inherit = array(
    "border-collapse" => 1,
    "border-spacing" => 1,
    "caption-side" => 1,
    "color" => 1,
    "cursor" => 1,
    "direction" => 1,
    "empty-cells" => 1,
    "font-family" => 1,
    "font-size" => 1,
    "font-style" => 1,
    "font-variant" => 1,
    "font-weight" => 1,
    "font-size-adjust" => 1,
    "font-stretch" => 1,
    "font" => 1,
    "letter-spacing" => 1,
    "line-height" => 1,
    "list-style-image" => 1,
    "list-style-position" => 1,
    "list-style-type" => 1,
    "list-style" => 1,
    "orphans" => 1,
    "quotes" => 1,
    "tab-size" => 1,
    "text-align" => 1,
    "text-align-last" => 1,
    "text-decoration-color" => 1,
    "text-indent" => 1,
    "text-justify" => 1,
    "text-shadow" => 1,
    "text-transform" => 1,
    "visibility" => 1,
    "white-space" => 1,
    "widows" => 1,
    "word-break" => 1,
    "word-spacing" => 1,
    "word-wrap" => 1);
  
  $css = array();
  
  $level = 0;
    
  # start the cascade
  while ($e) {
    # get css from the element attribute
    
    # get css from the element class
    
    # get css from the element id
    
    # get css associated with the element
    $tag = $e->tag;
    if (array_key_exists($tag, $bookrtf_css)) {
      foreach (array_keys($bookrtf_css[$tag]) as $key) {
        // inheritance by default
        if (!array_key_exists($key, $css) & ($level == 0 | array_key_exists( $key, $css_inherit))) {
          $css[$key] = $bookrtf_css[$tag][$key];
        }
        // inheritance by setting
        if (array_key_exists($key, $css)) {
          if (trim($css[$key]) == "inherit") {
            $css[$key] = $bookrtf_css[$tag][$key];
          }
        }
      }
    }  
    $e = $e->parent();
    $level++;
  }
  
  return bookrtf_css2rtf($css);
}

/**
 * Convert a CSS-array into the appropriate rtf style elements
 *
 * @param css 
 *   an array of css key-value pairs
 */

function bookrtf_css2rtf($css) {
  global $bookrtf_fonttbl;
  
  if (!is_array($css)) {
    return "";
  }

  $rtf = "";
  
  
  if (array_key_exists("margin-top", $css)) {
    $rtf .= "\\sb". bookrtf_convert_length($css["margin-top"]);
  }
  if (array_key_exists("margin-right", $css)) {
    $rtf .= "\\ri". bookrtf_convert_length($css["margin-right"]);
  }
  if (array_key_exists("margin-bottom", $css)) {
    $rtf .= "\\sa". bookrtf_convert_length($css["margin-bottom"]);
  }
  if (array_key_exists("margin-left", $css)) {
    $rtf .= "\\li". bookrtf_convert_length($css["margin-left"]);
  }
  if (array_key_exists("text-align", $css)) {
    // default is left so skip that
    switch(trim($css["text-align"])) {
      case "center":
        $rtf .= "\\qc";
        break;
      case "justify":
        $rtf .= "\\qj";
        break;
      case "left":
        $rtf .= "\\ql";
        break;
      case "right":
        $rtf .= "\\qr";
        break;
    }
  }
  if (array_key_exists("font-family", $css)) {
    $r = array();
    // In css a family of fonts is given, if the first is not available the 
    // second is tried etc. I'm not sure how rtf / word processors handle that.
    // Just pick the first one and hope for the best.
    
    preg_match("|^([^,]+),?|", $css["font-family"], $r);
    $font = trim($r[1]);
    $font = preg_replace("|\"|", "", $font);
    
    if (!array_key_exists($font, $bookrtf_fonttbl)) {
      $bookrtf_fonttbl[$font] = count($bookrtf_fonttbl);
    }
    if ($bookrtf_fonttbl[$font] != 0) {
       $rtf .= "\\f" . $bookrtf_fonttbl[$font];
     }
  }
  if (array_key_exists("font-size", $css)) {
    $rtf .= "\\fs". bookrtf_convert_font_size($css["font-size"]);
  }
  if (array_key_exists("font-weight", $css)) {
    switch(trim($css["font-weight"])) {
      case "bold":
        $rtf .= "\\b";
        break;
      case "normal":
        break;
    }
  }
  
  if (strlen($rtf) > 0) {
    $rtf .= " ";
  }
  return $rtf;
}

/**
 * Converter CSS length to RTF's twips
 *
 * @param css 
 *   The value in CSS, this is a string with the value and unit
 */

function bookrtf_convert_length($css) {
  // check if css has the right format
  preg_match("|^(\d+\.?\d*)([a-zA-Z]+)$|", trim($css), $r);
  if (count($r) == 0) {
    return 0;
  }
  $css_value = $r[1];
  $css_unit = $r[2];
  
  // length
  if ($css_unit == "cm") {
    return round($css_value / 2.54 * 1440);
  }
  if ($css_unit == "in") {
    return round($css_value * 1440);
  }
  if ($css_unit == "mm") {
    return round($css_value / 2.54 * 144);
  }
  if ($css_unit == "pt") {
    return round($css_value * 20);
  }
  if ($css_unit == "px") {
    return round($css_value * 15);
  }
  if ($css_unit == "pc") {
    return round($css_value * 240);
  }
  
  return 0;
}

/**
 * Converter from CSS font size to RTF's half points
 *
 * @param css 
 *   The value in CSS, this is a string with the value and unit
 */

function bookrtf_convert_font_size($css) {
  // check if css has the right format
  preg_match("|^(\d+\.?\d*)([a-zA-Z]+)$|", trim($css), $r);
  if (count($r) == 0) {
    return 24;
  }
  $css_value = $r[1];
  $css_unit = $r[2];

  // font size
  if ($css_unit == "cm") {
    return round($css_value / 2.54 * 144);
  }
  if ($css_unit == "in") {
    return round($css_value * 144);
  }
  if ($css_unit == "mm") {
    return  round($css_value / 2.54 * 14.4);
  }
  if ($css_unit == "pt") {
    return round($css_value * 2);
  } 
  if ($css_unit == "px") {
    return round($css_value * 1.5);
  }
  if ($css_unit == "pc") {
    return round($css_value * 24);
  }
  
  return 24;
}
