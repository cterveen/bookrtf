<?php
 
 /**
 * @file
 * A  module that exports books as rtf
 */
 

 /**
 * Manually load the libraries module to get access to libraries_get_path();
 * This should not be necessary!
 */
include_once(drupal_get_path("module", "libraries") . "/libraries.module");
 
 /**
 * Load the PHP simple HTML DOM parser if not done yet
 *
 * get it here: https://simplehtmldom.sourceforge.io/
 * save it to: sites/all/libraries/simle_html_dom/
 */
include_once(libraries_get_path("simple_html_dom") . "/simple_html_dom.php");

 /**
 * Load the css parser if not done yet
 *
 * get it here: https://github.com/Schepp/CSS-Parser
 * save it to: sites/all/libraries/schepp-css-parser/
 */ 
include_once(libraries_get_path("schepp-css-parser") . "/parser.php");
 
 /**
 * Implements hook_help().
 *
 * Displays help and module information.
 *
 * @param path 
 *   Which path of the site we're using to display help
 * @param arg 
 *   Array that holds the current path as returned from arg() function
 */
 
function bookrtf_help($path, $arg) {
  switch ($path) {
    case "admin/help#bookrtf":
      return '' . t("Exports a book as rtf file.") . '';
      break;
  }
}

/**
* Implements hook_menu().
*/

function bookrtf_menu() {
  $items = array();
  $items['book/rtf/1'] = array(
     'title' => 'Download',
     'page callback' => '_bookrtf_page',
     'page arguments' => array(2),
     'access arguments' => array('access content'),
     'type' => MENU_CALLBACK,
   );
   
   $items['admin/config/bookrtf'] = array(
    'title' => 'BookRTF',
    'description' => 'Configuration for BookRTF module',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('bookrtf_form'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM);
   
   
   return $items;
}

/** 
 * Implements hook_form
 */

function bookrtf_form($form, &$form_state) {

  /**
  * Options for the module (need a lot of that)
  *
  * - Custom title
  * - Custom filename
  * - Custom front_page
  * - Show table of contents
  * - Show index
  * - Download page text.
  */
  
  $form['bookrtf_title'] = array(
    '#type' => 'textfield',
    '#title' => t('Book title'),
    '#default_value' => variable_get('bookrtf_title', variable_get('site_name', "Default site name")),
    '#size' => 20,
    '#maxlength' => 20,
    '#description' => t('The title to use for the book'),
    '#required' => TRUE,
  );
  
  $form['bookrtf_filename'] = array(
    '#type' => 'textfield',
    '#title' => t('File name'),
    '#default_value' => variable_get('bookrtf_filename', "download.rtf"),
    '#size' => 20,
    '#maxlength' => 20,
    '#description' => t('The filename for the download'),
    '#required' => FALSE,
  );
  
  $form['bookrtf_style_from_attribute'] = array(
    '#type' => 'checkbox',
    '#title' => 'Use style attribute of the element',
    '#default_value' => variable_get('bookrtf_style_from_attribute', 1),
    '#description' => t('By default the style specified in the style attribute of the element is used. However, this usually is specified for the website and in the print version a different style can be prefered. By turning this setting off all styles set in the style attribute are ignored.'),);
  
  $form['bookrtf_front'] = array(
    '#type' => 'checkbox',
    '#title' => 'Include custom frontpage',
    '#default_value' => variable_get('bookrtf_front', 1),
    '#description' => t('The front page can be defined below'),);
  
  $form['bookrtf_flyleaf'] = array(
    '#type' => 'checkbox',
    '#title' => 'Include flyleaf',
    '#default_value' => variable_get('bookrtf_flyleaf', 1));
  
  $form['bookrtf_toc'] = array (
    '#type' => 'checkbox',
    '#title' => 'Include table of contents',
    '#default_value' => variable_get('bookrtf_toc', 1));
    
  $form['bookrtf_index'] = array(
    '#type' => 'checkbox',
    '#title' => 'Include index',
    '#default_value' => variable_get('bookrtf_index', 0));
    
  $form['bookrtf_header_left'] = array(
    '#type' => 'select',
    '#title' => t('Left header'),
    '#options' => array(
      0 => "Nothing",
      1 => "Book title",
      2 => "Chapter title",
      3 => "Page number"),
    '#default_value' => variable_get('bookrtf_header_left', 0));
    
  $form['bookrtf_header_right'] = array(
    '#type' => 'select',
    '#title' => t('Right header'),
    '#options' => array(
      0 => "Nothing",
      1 => "Book title",
      2 => "Chapter title",
      3 => "Page number"),
    '#default_value' => variable_get('bookrtf_header_right', 0));  
    
  $form['bookrtf_footer_left'] = array(
    '#type' => 'select',
    '#title' => t('Left footer'),
    '#options' => array(
      0 => "Nothing",
      1 => "Book title",
      2 => "Chapter title",
      3 => "Page number"),
    '#default_value' => variable_get('bookrtf_footer_left', 0));  
   
  $form['bookrtf_footer_right'] = array(
    '#type' => 'select',
    '#title' => t('Right footer'),
    '#options' => array(
      0 => "Nothing",
      1 => "Book title",
      2 => "Chapter title",
      3 => "Page number"),
    '#default_value' => variable_get('bookrtf_footer_right', 0));   
    
  $bookrtf_front_page = variable_get('bookrtf_front_page', array('value' => '<h3>'.variable_get('bookrtf_title', variable_get('site_name', "Default site name")).'</h3>', 'format' => 'full_html'));
  
  $form['bookrtf_front_page'] = array(
    '#type' => 'text_format',
    '#format' => $bookrtf_front_page['format'],
    '#title' => 'Custom frontpage',
    '#default_value' => $bookrtf_front_page['value'],
    '#description' => t('A custom frontpage for your book'));
      
  $form['bookrtf_download_title'] = array(
    '#type' => 'textfield',
    '#title' => t('Title of download page'),
    '#default_value' => variable_get('bookrtf_download_title', "Download"),
    '#size' => 20,
    '#maxlength' => 20,
    '#description' => t('The title to use for the download page'),
    '#required' => TRUE,);    
    
  $bookrtf_download_page = variable_get('bookrtf_download_page', array('value' => '<p><a href = "' . file_create_url('public://' . variable_get('bookrtf_filename', "download.rtf")) . '">Download ' . variable_get('bookrtf_filename', "download.rtf") . '</p>', 'format' => 'full_html'));
  $form['bookrtf_download_page'] = array(
    '#type' => 'text_format',
    '#format' => $bookrtf_download_page['format'],
    '#title' => t('Contents of download page'),
    '#default_value' => $bookrtf_download_page['value'],
    '#description' => t('The text of the download page'),
    '#required' => TRUE);

  return system_settings_form($form);
}

/**
 * Implements validation from the Form API.
 * 
 * @param $form
 *   A structured array containing the elements and properties of the form.
 * @param $form_state
 *   An array that stores information about the form's current state 
 *   during processing.
 */
 
function bookrtf_form_validate($form, &$form_state){
  $filename = $form_state['values']['bookrtf_filename'];
  if (strlen($filename) <= 4 | substr($filename, -4) != ".rtf") {
    form_set_error('bookrtf_filename', t('You must enter a valid filename that ends with .rtf'));
  }
}

 /**
 * Get the contents from print and, convert to RTF, save as file and show a download page.
 */

function _bookrtf_page($nid) {
  if (user_access('access content')) {
    $node = node_load($nid);
    if (isset($node->book)) {
      global $base_url;
      
      $tree = book_menu_subtree_data($node->book);        
      $content = bookrtf_index_traverse($tree);
      $content = bookrtf_convert($content, $base_url);
      
      file_put_contents(file_destination("public://" . variable_get('bookrtf_filename', "download.rtf"), FILE_EXISTS_REPLACE), $content);
      
      $bookrtf_download_page = variable_get('bookrtf_download_page', array('value' => '<p><a href = "' . file_create_url('public://' . variable_get('bookrtf_filename', "download.rtf")) . '">Download ' . variable_get('bookrtf_filename', "download.rtf") . '</p>', 'format' => 'full_html'));
      
      $page_array['index'] = array(
        '#title' => t(variable_get('bookrtf_download_title', "Download")),
        '#markup' => t($bookrtf_download_page['value']),
      );
   
      return $page_array;
    }
    else {
      drupal_not_found();
    }
  }
  else {
    drupal_access_denied();
  }  
}

 /**
 * Copy of book_index_traverse
 */

function bookrtf_index_traverse($tree) {
    $output = '';    
    
    foreach ($tree as $data) {
      // Note- access checking is already performed when building the tree.
      if ($node = node_load($data['link']['nid'], FALSE)) {
        $children = '';

        if ($data['below']) {
          $children = bookrtf_index_traverse($data['below']);
        }
      }
      
      $output .= book_node_export($node, $children);      
      
    }
    
    return $output;  
}

 /**
 * The engine, convert HTML output to RTF and add some shiny touches.
 */

function bookrtf_convert($content, $base_url) {
  global $bookrtf_firstpage;
  $bookrtf_firstpage = 1;
  // put some html tags around it so we can push it into the html converter.
  $content = "<html><body>" . $content . "</body></html>";
  
  // Remove white-space between structural elements
  foreach (array("td", "p", "li", "div", "h1", "h2", "h3", "ol", "ul") as $element) {
    $content = preg_replace("|<\/".$element.">[\s\r\n]+<|", "</".$element."><", $content);
    $content = preg_replace("|>[\s\r\n]+<".$element."|", "><".$element, $content);  
  }
  
  // style
  global $bookrtf_css;
  global $bookrtf_fonttbl;
  global $bookrtf_colortbl;
  $css = array("main" => array());
  
  foreach (array(drupal_get_path('module', "BookRTF") . "/rtf.css", drupal_get_path('theme', $GLOBALS['theme']) . "/css/rtf.css") as $css_file) {
    if (is_file($css_file)) {
      $css_parser = new CssParser();
      $css_parser->load_files($css_file);
      $css_parser->parse();
      $css = $css_parser->parsed;
      
      foreach (array_keys($css['main']) as $selector) {
        foreach(array_keys($css['main'][$selector]) as $property) {
          $bookrtf_css[$selector][$property] = $css['main'][$selector][$property];
        }
      }
    }  
  }    
  
  // get the default font from body
  if (array_key_exists("body", $bookrtf_css)) {
    if (array_key_exists("font-family", $bookrtf_css["body"])) {
      preg_match("|^([^,]+),?|", $bookrtf_css["body"]["font-family"], $r);
      $font = trim($r[1]);
      $font = preg_replace("|\"|", "", $font);
      $bookrtf_fonttbl[$font] = 0;
    }
  }
  
  // declare the colortable but no need to set a default
  $bookrtf_colortbl = array();
  
  $tags = array_keys($css["main"]);
  
  $book_title = variable_get('bookrtf_title', variable_get('site_name', "Default site name"));
  
  
  $html = str_get_html($content);
  $toc = $html->find("h1");
  
   /**
   * Start with the footer. This is done to grab the index tables.
   * Footer
   * - index
   */
   
   $footer = "";
  
  if (variable_get('bookrtf_index', 0)) {
    $footer .= "\r\n\\page\r\n\\sect\r\n";
    $footer .= "{\\headerl\\pard\\ql {\b ".$book_title."}\\par}\r\n";
    $footer .= "{\\headerr\\pard\\qr Index\\par}\r\n";
    $footer .= "{\\footerr\\pard\\qr \\chpgn \\par}\r\n";
    $footer .= "{\\footerl\\pard\\ql \\chpgn \\par}\r\n";
    $footer .= "{\\pard " . bookrtf_css2rtf(bookrtf_get_style($toc[0]));
    $footer .= "{\\*\\bkmkstart chapterIndex}{\\*\\bkmkend chapterIndex}Index";
    $footer .= "\\par}\r\n";
    $footer .= "\\sect \\sbknone \\cols2\r\n";  
  
    $anchors = $html->find('a[name]');
    $terms = array();
    foreach ($anchors as $a) {
      $label = $a->name;
      if (preg_match("|^index|", $label)) {
        $label = substr($label, 5);
        array_push($terms, $label);
      }
    }
    sort($terms);
  
    $cur_initial = "";
  
    global $index_id;
    $index_id = array();
    $i = 0;
  
    foreach ($terms as $t) {
      if (!isset($index_id[$t])) {
        $index_id[$t] = $i;
        $anchor = "index-" . $i ; 
        $i++;
  
        $initial = substr($t, 0, 1);
        if (is_numeric($initial)) {
          $initial = "#";
        }
        if ($initial != $cur_initial) {
          if ($cur_initial != "") {
            $footer .= "\\par}\r\n";
          }
          $footer .= "{\\pard\\fs28{\\b " . $initial . "\\b}\\par}\r\n";
          $footer .= "{\\pard\\ql ";
          $cur_initial = $initial;
        }
        $footer .= $t . " {\\field{\*\\fldinst PAGEREF ".$anchor."}}\\line\r\n";
      }
    }
    $footer .= "\\par}\r\n";
  }
  
  
  /** 
  * Then get the content.
  * This is done second because the font table might be appended during the
  * conversion process.
  *
  * The tough work is going to be done by bookrtf_traverse. 
  */
  
  $elements = $html->find('html');
  bookrtf_traverse($elements, $base_url);
  
  // dumb the new code back to $content
  $content = $html;  
  
  // strip all remaining tags
  $content = strip_tags($content);
    
  /**
   * HEADER
   * - Front page
   * - Flyleaf containing URL and date of download
   * - Table of contents
   * - Start of first page
   */   
    
  $header = "\\rtf1\\ansi\r\n";
  $header .= "\\deff0 {\\fonttbl ";
  if (!is_array($bookrtf_fonttbl)) {
    $header .= "{\\f0 Calibri;}";
  }
  else {
    foreach (array_keys($bookrtf_fonttbl) as $font) {
      $header .= "{\\f" . $bookrtf_fonttbl[$font] . "\\fnil " . $font . ";}";
    }
  }
  $header .= "}\r\n";
  if (count($bookrtf_colortbl) > 0) {
    $header .= "{\\colortbl ;";
    foreach (array_keys($bookrtf_colortbl) as $color) {
      $header .= " " . $color . ";";
    }
    $header .= "}\r\n";
  }  
  
  $header .= "\\vertdoc\\paperh16834\\paperw11909\r\n";
  $header .= "\\fet0\\facingp\\ftnbj\\ftnrstpg\\widowctrl\r\n";
  $header .= "\\plain\r\n";
  
  if (variable_get('bookrtf_front', 1)) {
    $bookrtf_firstpage = 0;
    $bookrtf_front_page = variable_get('bookrtf_front_page', array('value' => '<h3>'.$book_title.'</h3>', 'format' => 'full_html'));
    $bookrtf_front_page["value"] = "<html><body><h3>" . $bookrtf_front_page["value"] . "</body></html>";
    $title_html = str_get_html($bookrtf_front_page["value"]);
    $elements = $title_html->find('html');
    bookrtf_traverse($elements, $base_url);
    $title_html = strip_tags($title_html);
    $header .= $title_html;
  }  

  // flyleaf  
  if (variable_get('bookrtf_flyleaf', 1)) {
    if ($bookrtf_firstpage == 1) {
      $bookrtf_firstpage = 0;
    }
    else {
      $header .= "\\sect\\sftnrstpg\r\n";
    }
    $header .= "{\\pard\\qc";
    $header .= "{\\b " . $book_title . "}\\line\r\n";
    if (isset($base_url)) {
      $header .= $base_url;
    }
    $header .= "\\line\r\n\\line\r\n";
    $date = new DateTime();
    $header .= "Gegenereerd: " . date_format($date, "d-m-Y") . " \\par}\r\n";
  }
  
  // table of contents
  if (variable_get('bookrtf_toc', 1)) {
    if ($bookrtf_firstpage == 1) {
      $bookrtf_firstpage = 0;
    }
    else {
      $header .= "\\sect\\sftnrstpg\r\n";
    }
    
    $header .= "{\\pard " .  bookrtf_css2rtf(bookrtf_get_style($toc[0])) . "Inhoud\r\n";
    $header .= "\\par}\r\n{\\pard {";
        
    // remove the first title as this should be the title of the book and does not belong in the toc.
    $book_title_element = array_shift($toc);
    $book_title_element->outertext = "";
    foreach ($toc as $e) {
      // Assume title starts with the chapternumber
      $title = $e->innertext;
      preg_match("|^(\d+)\.\s|", $title, $match);
      $chapter = $match[1];
    
      $header .= "\\trowd";
      $header .= "\\cellx7000 \\cellx8309\r\n"; 
      $header .= "\\intbl\\pard " .$title . "\\cell";
      $header .= "\\qr{\\field{\*\\fldinst PAGEREF chapter".$chapter."}}\\cell\\row\r\n";
    }
  
    if (variable_get('bookrtf_index', 0)) {
      $header .= "\\trowd";
      $header .= "\\cellx7000 \\cellx8309\r\n"; 
      $header .= "\\intbl\\pard Index\\cell";
      $header .= "\\qr{\\field{\*\\fldinst PAGEREF chapterIndex}}\\cell\\row\r\n";
    }
    $header .= "}\\par}\r\n";
  }
  
  // FINAL DOCUMENT
  $content = "{" . $header . "\r\n" . $content . "\r\n" . $footer . "}";
    
  // SPECIAL CHARACTERS
  // extended ascii
  $content = preg_replace("|€|", "\'80", $content);
  // $content = preg_replace("|foo|", "\'81", $content);
  $content = preg_replace("|‚|", "\'82", $content);
  $content = preg_replace("|ƒ|", "\'83", $content);
  $content = preg_replace("|„|", "\'84", $content);
  $content = preg_replace("|…|", "\'85", $content);
  $content = preg_replace("|†|", "\'86", $content);
  $content = preg_replace("|‡|", "\'87", $content);
  $content = preg_replace("|ˆ|", "\'88", $content);
  $content = preg_replace("|‰|", "\'89", $content);
  $content = preg_replace("|Š|", "\'8a", $content);
  $content = preg_replace("|‹|", "\'8b", $content);
  $content = preg_replace("|Œ|", "\'8c", $content);
  // $content = preg_replace("|foo|", "\'8d", $content);
  $content = preg_replace("|Ž|", "\'8e", $content);
  // $content = preg_replace("|foo|", "\'8f", $content);
  $content = preg_replace("|‘|", "\'91", $content);
  $content = preg_replace("|’|", "\'92", $content);
  $content = preg_replace("|´|", "\'b4", $content);
  $content = preg_replace("|“|", "\'93", $content);
  $content = preg_replace("|”|", "\'94", $content);
  $content = preg_replace("|•|", "\'95", $content);
  $content = preg_replace("|–|", "\'96", $content);
  $content = preg_replace("|–|", "\'97", $content);
  $content = preg_replace("|˜|", "\'98", $content);
  $content = preg_replace("|™|", "\'99", $content);
  $content = preg_replace("|š|", "\'9a", $content);
  $content = preg_replace("|›|", "\'9b", $content);
  $content = preg_replace("|œ|", "\'9c", $content);
  // $content = preg_replace("|foo|", "\'9d", $content);
  $content = preg_replace("|ž|", "\'9e", $content);
  $content = preg_replace("|Ÿ|", "\'9f", $content);
  // $content = preg_replace("|foo|", "\'a0", $content);
  $content = preg_replace("|¡|", "\'a1", $content);
  $content = preg_replace("|¢|", "\'a2", $content);
  $content = preg_replace("|£|", "\'a3", $content);
  $content = preg_replace("|¤|", "\'a4", $content);
  $content = preg_replace("|¥|", "\'a5", $content);
  $content = preg_replace("|¦|", "\'a6", $content);
  $content = preg_replace("|§|", "\'a7", $content);
  $content = preg_replace("|¨|", "\'a8", $content);
  $content = preg_replace("|©|", "\'a9", $content);
  $content = preg_replace("|ª|", "\'aa", $content);
  $content = preg_replace("|«|", "\'ab", $content);
  $content = preg_replace("|¬|", "\'ac", $content);
  // $content = preg_replace("|foo|", "\'ad", $content); // Should be soft hyphen
  $content = preg_replace("|®|", "\'ae", $content);
  $content = preg_replace("|¯|", "\'af", $content);
  $content = preg_replace("|°|", "\'b0", $content);
  $content = preg_replace("|±|", "\'b1", $content);
  $content = preg_replace("|²|", "\'b2", $content);
  $content = preg_replace("|³|", "\'b3", $content);
  $content = preg_replace("|´|", "\'b4", $content);
  $content = preg_replace("|µ|", "\'b5", $content);
  $content = preg_replace("|¶|", "\'b6", $content);
  $content = preg_replace("|·|", "\'b7", $content);
  $content = preg_replace("|¸|", "\'b8", $content);
  $content = preg_replace("|¹|", "\'b9", $content);
  $content = preg_replace("|º|", "\'ba", $content);
  $content = preg_replace("|»|", "\'bb", $content);
  $content = preg_replace("|¼|", "\'bc", $content);
  $content = preg_replace("|½|", "\'bd", $content);
  $content = preg_replace("|¾|", "\'be", $content);
  $content = preg_replace("|¿|", "\'bf", $content);
  $content = preg_replace("|À|", "\'c0", $content);
  $content = preg_replace("|Á|", "\'c1", $content);
  $content = preg_replace("|Â|", "\'c2", $content);
  $content = preg_replace("|Ã|", "\'c3", $content);
  $content = preg_replace("|Ä|", "\'c4", $content);
  $content = preg_replace("|Å|", "\'c5", $content);
  $content = preg_replace("|Æ|", "\'c6", $content);
  $content = preg_replace("|Ç|", "\'c7", $content);
  $content = preg_replace("|È|", "\'c8", $content);
  $content = preg_replace("|É|", "\'c9", $content);
  $content = preg_replace("|Ê|", "\'ca", $content);
  $content = preg_replace("|Ë|", "\'cb", $content);
  $content = preg_replace("|Ì|", "\'cc", $content);
  $content = preg_replace("|Í|", "\'cd", $content);
  $content = preg_replace("|Î|", "\'ce", $content);
  $content = preg_replace("|Ï|", "\'cf", $content);
  $content = preg_replace("|Ð|", "\'d0", $content);
  $content = preg_replace("|Ñ|", "\'d1", $content);
  $content = preg_replace("|Ò|", "\'d2", $content);
  $content = preg_replace("|Ó|", "\'d3", $content);
  $content = preg_replace("|Ô|", "\'d4", $content);
  $content = preg_replace("|Õ|", "\'d5", $content);
  $content = preg_replace("|Ö|", "\'d6", $content);
  $content = preg_replace("|×|", "\'d7", $content);
  $content = preg_replace("|Ø|", "\'d8", $content);
  $content = preg_replace("|Ù|", "\'d9", $content);
  $content = preg_replace("|Ú|", "\'da", $content);
  $content = preg_replace("|Û|", "\'db", $content);
  $content = preg_replace("|Ü|", "\'dc", $content);
  $content = preg_replace("|Ý|", "\'dd", $content);
  $content = preg_replace("|Þ|", "\'de", $content);
  $content = preg_replace("|ß|", "\'df", $content);
  $content = preg_replace("|à|", "\'e0", $content);
  $content = preg_replace("|á|", "\'e1", $content);
  $content = preg_replace("|â|", "\'e2", $content);
  $content = preg_replace("|ã|", "\'e3", $content);
  $content = preg_replace("|ä|", "\'e4", $content);
  $content = preg_replace("|å|", "\'e5", $content);
  $content = preg_replace("|æ|", "\'e6", $content);
  $content = preg_replace("|ç|", "\'e7", $content);
  $content = preg_replace("|è|", "\'e8", $content);
  $content = preg_replace("|é|", "\'e9", $content);
  $content = preg_replace("|ê|", "\'ea", $content);
  $content = preg_replace("|ë|", "\'eb", $content);
  $content = preg_replace("|ì|", "\'ec", $content);
  $content = preg_replace("|í|", "\'ed", $content);
  $content = preg_replace("|î|", "\'ee", $content);
  $content = preg_replace("|ï|", "\'ef", $content);
  $content = preg_replace("|ð|", "\'f0", $content);
  $content = preg_replace("|ñ|", "\'f1", $content);
  $content = preg_replace("|ò|", "\'f2", $content);
  $content = preg_replace("|ó|", "\'f3", $content);
  $content = preg_replace("|ô|", "\'f4", $content);
  $content = preg_replace("|õ|", "\'f5", $content);
  $content = preg_replace("|ö|", "\'f6", $content);
  $content = preg_replace("|÷|", "\'f7", $content);
  $content = preg_replace("|ø|", "\'f8", $content);
  $content = preg_replace("|ù|", "\'f9", $content);
  $content = preg_replace("|ú|", "\'fa", $content);
  $content = preg_replace("|û|", "\'fb", $content);
  $content = preg_replace("|ü|", "\'fc", $content);
  $content = preg_replace("|ý|", "\'fd", $content);
  $content = preg_replace("|þ|", "\'fe", $content);
  $content = preg_replace("|ÿ|", "\'ff", $content);

  // html
  $content = preg_replace("|&amp;|", "&", $content);
  $content = preg_replace("|&deg;|", "\'b0", $content);
  $content = preg_replace("|&gt;|", ">", $content);
  $content = preg_replace("|&lt;|", "<", $content);
  $content = preg_replace("|&nbsp;|", " ", $content);
  $content = preg_replace("|&#039;|", "'", $content);

  // non breaking space
  $content = preg_replace("|\x{C2}\x{A0}|", " ", $content);

  return $content;
}

/**
 * HTML parsers may not spawn demons but if you use them to replace HTML tags
 * by RTF code they do attract gremlins as the parser gets in trouble with
 * nested tags (which occur a lot in HTML). Probably the parser is losing it's
 * structure. This is solved by going through the tree and start replacing tags
 * at the branches working up to the main stem.
 *
 * @param elements 
 *   the basic $elements from which to start
 * @param base_url 
 *   The base URL of the site, needed to convert links.
 */
 
function bookrtf_traverse ($elements, $base_url) {
  global $bookrtf_css;
  
  foreach ($elements as $e) {
    if ($e->first_child()) {
      $children = $e->children();
      bookrtf_traverse($children, $base_url);
    }
    
    // no children anymore --> start changing tags
    $tag = $e->tag;
    
    switch($tag) {
      case 'a':
        // this could be either links or anchors
        if ($e->href) {
          // link --> replace with footnote
          $url = $e->href;
          $title = $e->innertext;
          
          // no use to add a footnote if the link and label are the same.
          if (preg_match("|^(https?://)?(mailto:)?" . $title . "/?$|", $url)) {
            $e->outertext = $title;
          }
          else {
            $e->outertext = $title . "{\\footnote \\pard {\\up6 \\chftn} " . $url . "}"; 
          }          
        }
        else if ($e->name) {
         if (preg_match("|^index|", $e->name) & variable_get('bookrtf_index', 0)) {
           $label = substr($e->name, 5);
           global $index_id;
           $anchor = "index-" . $index_id[$label]; 
           $e->outertext = "{\\*\\bkmkstart ".$anchor."}{\\*\\bkmkend ".$anchor."}";
          }
        }
        break;
      case 'br':
        $e->outertext = "\\tab\\line\r\n";
        break;
      case 'h1':
        // start of a new chapter --> new page, right header contains chapter
        // title, bookmark for the table of contents
        $title = $e->innertext;
                
        global $bookrtf_firstpage;
        $rtf = "";
        if ($bookrtf_firstpage == 1 & variable_get('bookrtf_front', 1) == 0 & variable_get('bookrtf_flyleaf', 1) == 0 & variable_get('bookrtf_toc', 1) == 0) {
          $bookrtf_firstpage = 0;
        }
        else {
          $rtf .= "\\sect\\sftnrstpg\r\n";
        }
        
        switch(variable_get('bookrtf_header_left', 0)) {
          case 0:
            break;
          case 1:
            $rtf .= "{\\headerl\\pard ".bookrtf_css2rtf($bookrtf_css[".header-left"]) . variable_get('bookrtf_title', variable_get('site_name', "Default site name")) . "\\par}\r\n";
            break;
          case 2:
            $rtf .= "{\\headerl\\pard ".bookrtf_css2rtf($bookrtf_css[".header-left"]). $title . "\\par}\r\n";
            break;
          case 3:  
            $rtf .= "{\\headerl\\pard ".bookrtf_css2rtf($bookrtf_css[".header-left"])."\\chpgn \\par}\r\n";
            break;
        }
        
        switch(variable_get('bookrtf_header_right', 0)) {
          case 0:
            break;
          case 1:
            $rtf .= "{\\headerr\\pard ".bookrtf_css2rtf($bookrtf_css[".header-right"]) . variable_get('bookrtf_title', variable_get('site_name', "Default site name")) . "\\par}\r\n";
            break;
          case 2:
            $rtf .= "{\\headerr\\pard ".bookrtf_css2rtf($bookrtf_css[".header-right"]). $title . "\\par}\r\n";
            break;
          case 3:  
            $rtf .= "{\\headerr\\pard ".bookrtf_css2rtf($bookrtf_css[".header-right"])."\\chpgn \\par}\r\n";
            break;
        }
        
        switch(variable_get('bookrtf_footer_left', 0)) {
          case 0:
            break;
          case 1:
            $rtf .= "{\\footerl\\pard ".bookrtf_css2rtf($bookrtf_css[".footer-left"]) . variable_get('bookrtf_title', variable_get('site_name', "Default site name")) . "\\par}\r\n";
            break;
          case 2:
            $rtf .= "{\\footerl\\pard ".bookrtf_css2rtf($bookrtf_css[".footer-left"]). $title . "\\par}\r\n";
            break;
          case 3:  
            $rtf .= "{\\footerl\\pard ".bookrtf_css2rtf($bookrtf_css[".footer-left"])."\\chpgn \\par}\r\n";
            break;
        }
        
        switch(variable_get('bookrtf_footer_right', 0)) {
          case 0:
            break;
          case 1:
            $rtf .= "{\\footerr\\pard ".bookrtf_css2rtf($bookrtf_css[".footer-right"]) . variable_get('bookrtf_title', variable_get('site_name', "Default site name")) . "\\par}\r\n";
            break;
          case 2:
            $rtf .= "{\\footerr\\pard ".bookrtf_css2rtf($bookrtf_css[".footer-right"]). $title . "\\par}\r\n";
            break;
          case 3:  
            $rtf .= "{\\footerr\\pard ".bookrtf_css2rtf($bookrtf_css[".footer-right"])."\\chpgn \\par}\r\n";
            break;
        }          
          

        // if the chapter starts with a number it should be in the index, add a bookmark for it
        if (preg_match("|^(\d+)\.\s|", $title, $match)) {
          $chapter = $match[1];
          $rtf .= "{\\*\\bkmkstart chapter".$chapter."}{\\*\\bkmkend chapter".$chapter."}\r\n";
        }
        $rtf .= "{\\pard\\keepn " . bookrtf_css2rtf(bookrtf_get_style($e)) . $title . "\\par}\r\n";
        
        $e->outertext = $rtf;
        break;
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        $e->outertext = "{\\pard\\keepn " . bookrtf_css2rtf(bookrtf_get_style($e)) . $e->innertext . "\\par}\r\n";
        break;
      case 'i': 
        $e->outertext = "{\\i " . $e->innertext . "}";
        break;
      case 'img':
        $url = $e->src;
        
        // assume relative url
        if (isset($base_url) & substr($url, 0, 4) != "http") {
          $url = $base_url . $url;
        }
        
        $string = file_get_contents($url);
        
        $img = imagecreatefromstring($string);
        
        $width = imagesx($img);
        $height = imagesy($img);
        $ratio = $width/$height;
        
        // asume full page width A4 - margins = 11909 - 2x1800  = 8309 twips
        $picwidth = 8309;
        $picheight = round($picwidth / $ratio);
        $scalex = 100;
        $scaley = 100;

        $rtf = "{\\pard{\\pict\\picw".$width."\\pich".$height."\\picwgoal".$picwidth."\\pichgoal".$picheight."\\picscalex".$scalex."\\picscaley".$scaley;
    
        // set image type (jpg or png supported)
        if (substr($url, -4) == ".png") {
          $rtf .= "\pngblip\r\n";
        }
        else if (substr($url, -4) == ".jpg" or substr($url, -5) == ".jpeg") {
          $rtf .= "\jpegblip\r\n";
        }

        $hex = bin2hex($string);
        $hex = wordwrap($hex, 80, "\r\n", TRUE);
        
        $rtf .= $hex;
        $rtf .= "\r\n}\\par}\r\n";
        
        $e->outertext = $rtf;
        break;
      case 'li':
        /**
         * This might be a bit dirty but as I'm not going to make elaborate
         * list structures I feel confident working from li backwards and
         * strip out the list-tags later.
         */
         
        $level = 0;
        $type = "ul";
        $number = 1;
        $last = 1;
        
        // Type, level
        $p = $e->parent();
        while($p) {
          if ($p->tag == "ul" | $p->tag == "ol") {
            if ($level == 0) {
              $type = $p->tag;
            }
            $level++;
          }
          $p = $p->parent();
        }
        // Item number
        $s = $e->prev_sibling();
        while($s) {
          if ($s->tag == "li") {
            $number++;
          }
          $s = $s->prev_sibling();
        }
        // Last item?
        $s = $e->next_sibling();
        while($s) {
          if ($s->tag == "li") {
            $last = 0;
            break;
          }
          $s = $s->next_sibling();
        }
        
        $rtf = "";
        // if the first item of a nested list close the current paragraph.
        // TODO: might want to check if the list is inside a paragraph and do
        // that anyway
        if ($level > 1 & $number == 1) {
          $rtf .= "\\par}\r\n";
        }
        $rtf .= "{\\pard " . bookrtf_css2rtf(bookrtf_get_style($e));
        
        $firstindent = -360;
        $lineindent = 720 * $level;
        
        $rtf .= "\\fi" . $firstindent . "\\li". $lineindent;
        if ($type == "ul") {
          $rtf .= "\\bullet\\tab ";
        }
        else {
          $rtf .= " " . $array['id'] . ".\\tab ";
        }
        $rtf .= $e->innertext;
        
        // finish the paragraph unless it's the last item in a nested list
        // TODO this will give trouble if there's tekst after the nested list.
        // This text will be included in the last item of the nested list at
        // the moment.        
        if ($last != 1 | $level == 1) {
          $rtf .= "\\par}\r\n";
        }
        if ($level == 1 & $last == 1) {
          // add some empty space after the list
          // TODO this creates an empty line, would be nicer if I could make a configurable height.
          $rtf .= "\r\n{\\pard\\sa0\\par}\r\n"; 
        }
        $e->outertext = $rtf;
        break;
      case 'p':
        $e->outertext = "{\\pard " . bookrtf_css2rtf(bookrtf_get_style($e)) . $e->innertext . "\\par}\r\n";
        break;
      case 's':
      case 'del':
      case 'ins':
      case 'span':
        $e->outertext = "{" . bookrtf_css2rtf(bookrtf_get_style($e)) . $e->innertext . "}";
        break;
      case 'strong': 
      case 'b':  
        $e->outertext = "{\\b " . $e->innertext . "}";
        break;
      case 'strike':
        $e->outertext = "{\\strike " . $e->innertext . "}";
        break;
      case 'sub':
        $e->outertext = "{\\sub " . $e->innertext . "}";
        break;
      case 'sup': 
        $e->outertext = "{\\super " . $e->innertext . "}";
        break;
      case 'tbody':
        /**
         * Tables are a little bit more complicated than lists. I do not feel
         * confident working backwards from cells. Better to store the whole
         * table and than put it down again.
         */
        
        $num_rows = 0;
        $num_cols = 0;
        $table;
        $colwidth = array();        

        // retrieve table contents and some required specifications
        $rows = $e->children();
        foreach ($rows as $r) {
          if ($r->tag != "tr") {
            continue;
          }
          $num_rows++;
          $cells = $r->children();
          $cur_cols = 0;
          foreach ($cells as $c) {
            if ($c->tag != 'td' & $c->tag != 'th') {
              continue;
            }
            $cur_cols++;
            $table[$num_rows][$cur_cols]['element'] = $c;
            $table[$num_rows][$cur_cols]['innertext'] = $c->innertext;
            $table[$num_rows][$cur_cols]['col'] = $cur_cols;
            if ($c->colspan) {
              $table[$num_rows][$cur_cols]['colspan'] = $c->colspan;
            }
            else {
              $table[$num_rows][$cur_cols]['colspan'] = 1;
            }
            
            $css = bookrtf_get_style($c);
            $table[$num_rows][$cur_cols]['style'] = $css;
            
            if (array_key_exists("width", $css)) {
              $colwidth[$cur_cols] = bookrtf_convert_length($css["width"]);
            }            
            
            // correct cur_cols for colspan.
            $cur_cols += $table[$num_rows][$cur_cols]['colspan']-1;
          }
          if ($cur_cols > $num_cols) {
            $num_cols = $cur_cols;
          }
        }
        
        /**
         * Calculate column width
         * 1. Determined width already defined
         * 2. Space out evenly over the remaining columns
         */
         
        $colright = array();
        $widthdefined = 0;
        $auto = 0;
        for ($col = 1; $col <= $num_cols; $col++) {
          if (array_key_exists($col, $colwidth)) {
            $widthdefined += $colwidth[$col];
          }
          else {
            $auto++;
          }
        }
        
        // standard pagewidth = 13909 - 2x1800 = 9309
        $autowidth = (9309 - $widthdefined)/$auto;
        
        $colleft = 0;
        for ($col = 1; $col <= $num_cols; $col++) {
          if (array_key_exists($col, $colwidth)) {
            $colleft += $colwidth[$col];
          }
          else {
            $colleft += $autowidth;
          }
          $colright[$col] = ceil($colleft);
        }
        
        // now we have the info start building it up again
        $rtf = "{";
        foreach ($table as $row) {
          $rtf .= "\\trowd\r\n";
          
          foreach ($row as $cell) {
                    // add the borders here
            foreach (array("border-top", "border-right", "border-bottom", "border-left") as $border) {
            
              if (array_key_exists($border . "-width", $cell["style"])) {
                $rtf .= "\\clbrdr" . substr($border, 7, 1);
                $rtf .= "\\brdrw" . bookrtf_convert_length($cell["style"][$border . "-width"]);
                if (array_key_exists($border . "-style", $cell["style"])) {
                  switch(trim($cell["style"][$border . "-style"])) {
                    case "dotted":
                      $rtf .= "\\brdrdot ";
                      break;
                    case "dashed":
                      $rtf .= "\\brdrdash ";
                      break;
                    case "double":
                      $rtf .= "\\brdrdb ";
                      break;
                    case "hidden":
                    case "none":
                      $rtf .= "\\brdrnone ";
                      break;
                    default:
                      $rtf .= "\\brdrs ";
                      break;
                  }
                }
                else {
                  $rtf .= "\\brdrs ";
                }                
              }
            }
            
            if (array_key_exists("vertical-align", $cell["style"])) {
              switch (trim($cell["style"]["vertical-align"])) {
                case "top":
                  $rtf .= "\\clvertalt";
                  break;
                case "middle":
                  $rtf .= "\\clvertalc";
                  break;
                case "bottom":
                  $rtf .= "\\clvertalb";
                  break;
              }
            }
          
            $rtf .= "\\cellx";
            $rtf .= $colright[$cell['col']+$cell['colspan']-1];
            $rtf .= "\r\n";
          }
          foreach ($row as $cell) {
            $rtf .= "\\intbl{" . bookrtf_css2rtf($cell['style']) . $cell['innertext'] . "}\\cell\r\n";
          }
          $rtf .= "\\row\r\n";
        }
        $rtf .= "}\r\n{\\pard\\sa0\\par}\r\n";
          
        $e->outertext = $rtf;
        break;
      case 'title':
        $e->outertext = "";
        break;
      case 'u':
        // switch to css to get the correct style (and color?);
        $css = bookrtf_get_style($e);
        if (!array_key_exists("text-decoration", $css)) {
          $css["text-decoration"] = "underline";
        }
        else {
          if (!preg_match("|underline|", $css["text-decoration"])) {
            $css["text-decoration"] = $css["text-decoration"] . " underline";
          }
        }
        
        $e->outertext = "{" . bookrtf_css2rtf($css) . $e->innertext . "}";
        break;
    }
  }
}

/**
 * Get the appropriate style for an HTML element and return string of rtf style
 * commands.
 *
 * @param e 
 *   an element from the html table
 */

function bookrtf_get_style($e) {
  global $bookrtf_css;
  
  // most of these aren't used
  $css_inherit = array(
    "border-collapse" => 1,
    "border-spacing" => 1,
    "caption-side" => 1,
    "color" => 1,
    "cursor" => 1,
    "direction" => 1,
    "empty-cells" => 1,
    "font-family" => 1,
    "font-size" => 1,
    "font-style" => 1,
    "font-variant" => 1,
    "font-weight" => 1,
    "font-size-adjust" => 1,
    "font-stretch" => 1,
    "font" => 1,
    "letter-spacing" => 1,
    "line-height" => 1,
    "list-style-image" => 1,
    "list-style-position" => 1,
    "list-style-type" => 1,
    "list-style" => 1,
    "orphans" => 1,
    "quotes" => 1,
    "tab-size" => 1,
    "text-align" => 1,
    "text-align-last" => 1,
    "text-decoration-color" => 1,
    "text-indent" => 1,
    "text-justify" => 1,
    "text-shadow" => 1,
    "text-transform" => 1,
    "visibility" => 1,
    "white-space" => 1,
    "widows" => 1,
    "word-break" => 1,
    "word-spacing" => 1,
    "word-wrap" => 1);
  
  $css = array();
  
  $level = 0;
    
  # start the cascade
  while ($e) {
    # get css from the element attribute
    $style = $e->style;
    if ($style != "" & variable_get('bookrtf_style_from_attribute', 1)) {
      $style = ".attribute {" . $style . " }";
      $css_parser = new CssParser();
      $css_parser->load_string($style);
      $css_parser->parse();
      $my_css = $css_parser->parsed;
      
      foreach (array_keys($my_css["main"][".attribute"]) as $property) {
        // inheritance by default
        if (!array_key_exists($property, $css) & ($level == 0 | array_key_exists($property, $css_inherit))) {
          $css[$property] = $my_css["main"][".attribute"][$property];
        }
        // inheritance by setting
        if (array_key_exists($property, $css)) {
          if (trim($css[$property]) == "inherit") {
            $css[$property] = $my_css["main"][".attribute"][$property];
          }
        }
      }
    }
    
    # get css from the element id
    $id = "#" . $e->id;
    if (array_key_exists($id, $bookrtf_css)) {
      foreach (array_keys($bookrtf_css[$id]) as $property) {
        // inheritance by default
        if (!array_key_exists($property, $css) & ($level == 0 | array_key_exists($property, $css_inherit))) {
          $css[$property] = $bookrtf_css[$id][$property];
        }
        // inheritance by setting
        if (array_key_exists($property, $css)) {
          if (trim($css[$property]) == "inherit") {
            $css[$property] = $bookrtf_css[$id][$property];
          }
        }
      }
    }
    
    # get css from the element class
    $class = "." . $e->class;
    if (array_key_exists($class, $bookrtf_css)) {
      foreach (array_keys($bookrtf_css[$class]) as $property) {
        // inheritance by default
        if (!array_key_exists($property, $css) & ($level == 0 | array_key_exists($property, $css_inherit))) {
          $css[$property] = $bookrtf_css[$class][$property];
        }
        // inheritance by setting
        if (array_key_exists($property, $css)) {
          if (trim($css[$property]) == "inherit") {
            $css[$property] = $bookrtf_css[$class][$property];
          }
        }
      }
    }
    
    # get css associated with the element
    $tag = $e->tag;
    if (array_key_exists($tag, $bookrtf_css)) {
      foreach (array_keys($bookrtf_css[$tag]) as $property) {
        // inheritance by default
        if (!array_key_exists($property, $css) & ($level == 0 | array_key_exists($property, $css_inherit))) {
          $css[$property] = $bookrtf_css[$tag][$property];
        }
        // inheritance by setting
        if (array_key_exists($property, $css)) {
          if (trim($css[$property]) == "inherit") {
            $css[$property] = $bookrtf_css[$tag][$property];
          }
        }
      }
    }  
    $e = $e->parent();
    $level++;
  }
  
  return $css;
}

/**
 * Convert a CSS-array into the appropriate rtf style elements
 *
 * @param css 
 *   an array of css key-value pairs
 */

function bookrtf_css2rtf($css) {
  global $bookrtf_fonttbl;
  global $bookrtf_colortbl;
  
  if (!is_array($css)) {
    return "";
  }

  $rtf = "";
  
  // use a bunch of if statements rather than switch to group tags
  if (array_key_exists("margin-top", $css)) {
    $rtf .= "\\sb". bookrtf_convert_length($css["margin-top"]);
  }
  if (array_key_exists("margin-right", $css)) {
    $rtf .= "\\ri". bookrtf_convert_length($css["margin-right"]);
  }
  if (array_key_exists("margin-bottom", $css)) {
    $rtf .= "\\sa". bookrtf_convert_length($css["margin-bottom"]);
  }
  if (array_key_exists("margin-left", $css)) {
    $rtf .= "\\li". bookrtf_convert_length($css["margin-left"]);
  }
  if (array_key_exists("text-align", $css)) {
    // default is left so skip that
    switch(trim($css["text-align"])) {
      case "center":
        $rtf .= "\\qc";
        break;
      case "justify":
        $rtf .= "\\qj";
        break;
      case "left":
        $rtf .= "\\ql";
        break;
      case "right":
        $rtf .= "\\qr";
        break;
    }
  }
  if (array_key_exists("font-family", $css)) {
    // In css a family of fonts is given, if the first is not available the 
    // second is tried etc. RTF doesn't seem to support this so pick the first    
    $r = array();    
    preg_match("|^([^,]+),?|", $css["font-family"], $r);
    $font = trim($r[1]);
    $font = preg_replace("|\"|", "", $font);
    
    if (!array_key_exists($font, $bookrtf_fonttbl)) {
      $bookrtf_fonttbl[$font] = count($bookrtf_fonttbl);
    }
    if ($bookrtf_fonttbl[$font] != 0) {
       $rtf .= "\\f" . $bookrtf_fonttbl[$font];
     }
  }
  if (array_key_exists("font-size", $css)) {
    $rtf .= "\\fs". bookrtf_convert_font_size($css["font-size"]);
  }
  if (array_key_exists("font-weight", $css)) {
    switch(trim($css["font-weight"])) {
      case "bold":
        $rtf .= "\\b";
        break;
      case "normal":
        break;
    }
  }
  if (array_key_exists("color", $css)) {
    $color = bookrtf_convert_color($css["color"]);
    if ($color != 0) {
      $rtf .= "\\cf" . $color;
    }
  }
  if (array_key_exists("text-decoration", $css)) {
    // multiple values are accepted
    $values = explode(" ", trim($css["text-decoration"]));
    foreach ($values as $v) {
      switch(trim($v)) {
        case "line-through":
          $rtf .= "\\strike";
          break;
        case "underline":
          if (array_key_exists("text-decoration-style", $css)) {
            switch(trim($css["text-decoration-style"])) {
              case "initial":
              case "inherit":
              case "solid":
                $rtf .= "\\ul";
                break;
              case "double":
                $rtf .= "\\uldb";
                break;
              case "dotted":
                $rtf .= "\\uld";
                break;
              case "dashed":
                $rtf .= "\\uldash";
                break;
              case "wavy":
                $rtf .= "\\ulwave";
                break;
              default:
                $rtf .= "\\ul";
                break;
            }
          }
          else {
            $rtf .= "\\ul";
          }
          break;
        case "none":
          $rtf .= "";
          break;
      }
    }
  }
  if (array_key_exists("text-decoration-color", $css)) {
    $rtf .= "\\ulc" . bookrtf_convert_color($css["text-decoration-color"]);
  }  
  if (strlen($rtf) > 0) {
    $rtf .= " ";
  }
  return $rtf;
}

/**
 * Convert CSS colors to a position in the colortable
 *
 * @param css 
 *   The value in CSS, this is a string with the value and unit
 */
function bookrtf_convert_color($css) {
  global $bookrtf_colortbl;
  
  $color = "";
  if (preg_match("|^rgb\((\d+),(\d+),(\d+)\)$|", trim($css) ,$r)) {
    $red = $r[1];
    $green = $r[2];
    $blue = $r[3];
    if ($red >=0 & $red <= 255 & $green >=0 & $green <= 255 & $blue >=0 & $blue <= 255) {
      $color = "\\red" . $red . "\\green" . $green . "\\blue" . $blue;
    }
  }
  if (preg_match("|^\#([0-9a-fA-F][0-9a-fA-F])([0-9a-fA-F][0-9a-fA-F])([0-9a-fA-F][0-9a-fA-F])$|", trim($css), $r)) {
    $red = hexdec($r[1]);
    $green = hexdec($r[2]);
    $blue = hexdec($r[3]);
    if ($red >=0 & $red <= 255 & $green >=0 & $green <= 255 & $blue >=0 & $blue <= 255) {
      $color = "\\red" . $red . "\\green" . $green . "\\blue" . $blue;
    }
  }
  if (preg_match("|^\w+$|", trim($css))) {
    $css_color_names = array(
      "aliceblue" => "\\red240\\green248\\blue255",
      "antiquewhite" => "\\red250\\green235\\blue215",
      "aqua" => "\\red0\\green255\\blue255",
      "aquamarine" => "\\red127\\green255\\blue212",
      "azure" => "\\red240\\green255\\blue255",
      "beige" => "\\red245\\green245\\blue220",
      "bisque" => "\\red255\\green228\\blue196",
      "black" => "\\red0\\green0\\blue0",
      "blanchedalmond" => "\\red255\\green235\\blue205",
      "blue" => "\\red0\\green0\\blue255",
      "blueviolet" => "\\red138\\green43\\blue226",
      "brown" => "\\red165\\green42\\blue42",
      "burlywood" => "\\red222\\green184\\blue135",
      "cadetblue" => "\\red95\\green158\\blue160",
      "chartreuse" => "\\red127\\green255\\blue0",
      "chocolate" => "\\red210\\green105\\blue30",
      "coral" => "\\red255\\green127\\blue80",
      "cornflowerblue" => "\\red100\\green149\\blue237",
      "cornsilk" => "\\red255\\green248\\blue220",
      "crimson" => "\\red220\\green20\\blue60",
      "cyan" => "\\red0\\green255\\blue255",
      "darkblue" => "\\red0\\green0\\blue139",
      "darkcyan" => "\\red0\\green139\\blue139",
      "darkgoldenrod" => "\\red184\\green134\\blue11",
      "darkgray" => "\\red169\\green169\\blue169",
      "darkgrey" => "\\red169\\green169\\blue169",
      "darkgreen" => "\\red0\\green100\\blue0",
      "darkkhaki" => "\\red189\\green183\\blue107",
      "darkmagenta" => "\\red139\\green0\\blue139",
      "darkolivegreen" => "\\red85\\green107\\blue47",
      "darkorange" => "\\red255\\green140\\blue0",
      "darkorchid" => "\\red153\\green50\\blue204",
      "darkred" => "\\red139\\green0\\blue0",
      "darksalmon" => "\\red233\\green150\\blue122",
      "darkseagreen" => "\\red143\\green188\\blue143",
      "darkslateblue" => "\\red72\\green61\\blue139",
      "darkslategray" => "\\red47\\green79\\blue79",
      "darkslategrey" => "\\red47\\green79\\blue79",
      "darkturquoise" => "\\red0\\green206\\blue209",
      "darkviolet" => "\\red148\\green0\\blue211",
      "deeppink" => "\\red255\\green20\\blue147",
      "deepskyblue" => "\\red0\\green191\\blue255",
      "dimgray" => "\\red105\\green105\\blue105",
      "dimgrey" => "\\red105\\green105\\blue105",
      "dodgerblue" => "\\red30\\green144\\blue255",
      "firebrick" => "\\red178\\green34\\blue34",
      "floralwhite" => "\\red255\\green250\\blue240",
      "forestgreen" => "\\red34\\green139\\blue34",
      "fuchsia" => "\\red255\\green0\\blue255",
      "gainsboro" => "\\red220\\green220\\blue220",
      "ghostwhite" => "\\red248\\green248\\blue255",
      "gold" => "\\red255\\green215\\blue0",
      "goldenrod" => "\\red218\\green165\\blue32",
      "gray" => "\\red128\\green128\\blue128",
      "grey" => "\\red128\\green128\\blue128",
      "green" => "\\red0\\green128\\blue0",
      "greenyellow" => "\\red173\\green255\\blue47",
      "honeydew" => "\\red240\\green255\\blue240",
      "hotpink" => "\\red255\\green105\\blue180",
      "indianred" => "\\red205\\green92\\blue92",
      "indigo" => "\\red75\\green0\\blue130",
      "ivory" => "\\red255\\green255\\blue240",
      "khaki" => "\\red240\\green230\\blue140",
      "lavender" => "\\red230\\green230\\blue250",
      "lavenderblush" => "\\red255\\green240\\blue245",
      "lawngreen" => "\\red124\\green252\\blue0",
      "lemonchiffon" => "\\red255\\green250\\blue205",
      "lightblue" => "\\red173\\green216\\blue230",
      "lightcoral" => "\\red240\\green128\\blue128",
      "lightcyan" => "\\red224\\green255\\blue255",
      "lightgoldenrodyellow" => "\\red250\\green250\\blue210",
      "lightgray" => "\\red211\\green211\\blue211",
      "lightgrey" => "\\red211\\green211\\blue211",
      "lightgreen" => "\\red144\\green238\\blue144",
      "lightpink" => "\\red255\\green182\\blue193",
      "lightsalmon" => "\\red255\\green160\\blue122",
      "lightseagreen" => "\\red32\\green178\\blue170",
      "lightskyblue" => "\\red135\\green206\\blue250",
      "lightslategray" => "\\red119\\green136\\blue153",
      "lightslategrey" => "\\red119\\green136\\blue153",
      "lightsteelblue" => "\\red176\\green196\\blue222",
      "lightyellow" => "\\red255\\green255\\blue224",
      "lime" => "\\red0\\green255\\blue0",
      "limegreen" => "\\red50\\green205\\blue50",
      "linen" => "\\red250\\green240\\blue230",
      "magenta" => "\\red255\\green0\\blue255",
      "maroon" => "\\red128\\green0\\blue0",
      "mediumaquamarine" => "\\red102\\green205\\blue170",
      "mediumblue" => "\\red0\\green0\\blue205",
      "mediumorchid" => "\\red186\\green85\\blue211",
      "mediumpurple" => "\\red147\\green112\\blue219",
      "mediumseagreen" => "\\red60\\green179\\blue113",
      "mediumslateblue" => "\\red123\\green104\\blue238",
      "mediumspringgreen" => "\\red0\\green250\\blue154",
      "mediumturquoise" => "\\red72\\green209\\blue204",
      "mediumvioletred" => "\\red199\\green21\\blue133",
      "midnightblue" => "\\red25\\green25\\blue112",
      "mintcream" => "\\red245\\green255\\blue250",
      "mistyrose" => "\\red255\\green228\\blue225",
      "moccasin" => "\\red255\\green228\\blue181",
      "navajowhite" => "\\red255\\green222\\blue173",
      "navy" => "\\red0\\green0\\blue128",
      "oldlace" => "\\red253\\green245\\blue230",
      "olive" => "\\red128\\green128\\blue0",
      "olivedrab" => "\\red107\\green142\\blue35",
      "orange" => "\\red255\\green165\\blue0",
      "orangered" => "\\red255\\green69\\blue0",
      "orchid" => "\\red218\\green112\\blue214",
      "palegoldenrod" => "\\red238\\green232\\blue170",
      "palegreen" => "\\red152\\green251\\blue152",
      "paleturquoise" => "\\red175\\green238\\blue238",
      "palevioletred" => "\\red219\\green112\\blue147",
      "papayawhip" => "\\red255\\green239\\blue213",
      "peachpuff" => "\\red255\\green218\\blue185",
      "peru" => "\\red205\\green133\\blue63",
      "pink" => "\\red255\\green192\\blue203",
      "plum" => "\\red221\\green160\\blue221",
      "powderblue" => "\\red176\\green224\\blue230",
      "purple" => "\\red128\\green0\\blue128",
      "rebeccapurple" => "\\red102\\green51\\blue153",
      "red" => "\\red255\\green0\\blue0",
      "rosybrown" => "\\red188\\green143\\blue143",
      "royalblue" => "\\red65\\green105\\blue225",
      "saddlebrown" => "\\red139\\green69\\blue19",
      "salmon" => "\\red250\\green128\\blue114",
      "sandybrown" => "\\red244\\green164\\blue96",
      "seagreen" => "\\red46\\green139\\blue87",
      "seashell" => "\\red255\\green245\\blue238",
      "sienna" => "\\red160\\green82\\blue45",
      "silver" => "\\red192\\green192\\blue192",
      "skyblue" => "\\red135\\green206\\blue235",
      "slateblue" => "\\red106\\green90\\blue205",
      "slategray" => "\\red112\\green128\\blue144",
      "slategrey" => "\\red112\\green128\\blue144",
      "snow" => "\\red255\\green250\\blue250",
      "springgreen" => "\\red0\\green255\\blue127",
      "steelblue" => "\\red70\\green130\\blue180",
      "tan" => "\\red210\\green180\\blue140",
      "teal" => "\\red0\\green128\\blue128",
      "thistle" => "\\red216\\green191\\blue216",
      "tomato" => "\\red255\\green99\\blue71",
      "turquoise" => "\\red64\\green224\\blue208",
      "violet" => "\\red238\\green130\\blue238",
      "wheat" => "\\red245\\green222\\blue179",
      "white" => "\\red255\\green255\\blue255",
      "whitesmoke" => "\\red245\\green245\\blue245",
      "yellow" => "\\red255\\green255\\blue0",
      "yellowgreen" => "\\red154\\green205\\blue50");

    $css = strtolower(trim($css));
    if (array_key_exists($css, $css_color_names)) {
      $color = $css_color_names[$css];
    }
  }
  
  if ($color == "") {
    return 0;
  }
  
  if (!array_key_exists($color, $bookrtf_colortbl)) {
     $bookrtf_colortbl[$color] = count($bookrtf_colortbl)+1;
  }
  return $bookrtf_colortbl[$color];  
}

/**
 * Convert CSS length to RTF's twips
 *
 * @param css 
 *   The value in CSS, this is a string with the value and unit
 */

function bookrtf_convert_length($css) {
  // check if css has the right format
  preg_match("|^(\d+\.?\d*)([a-zA-Z]+)$|", trim($css), $r);
  if (count($r) == 0) {
    return 0;
  }
  $css_value = $r[1];
  $css_unit = $r[2];
  
  // length
  if ($css_unit == "cm") {
    return round($css_value / 2.54 * 1440);
  }
  if ($css_unit == "in") {
    return round($css_value * 1440);
  }
  if ($css_unit == "mm") {
    return round($css_value / 2.54 * 144);
  }
  if ($css_unit == "pt") {
    return round($css_value * 20);
  }
  if ($css_unit == "px") {
    return round($css_value * 15);
  }
  if ($css_unit == "pc") {
    return round($css_value * 240);
  }
  
  return 0;
}

/**
 * Converter from CSS font size to RTF's half points
 *
 * @param css 
 *   The value in CSS, this is a string with the value and unit
 */

function bookrtf_convert_font_size($css) {
  // check if css has the right format
  preg_match("|^(\d+\.?\d*)([a-zA-Z]+)$|", trim($css), $r);
  if (count($r) == 0) {
    return 24;
  }
  $css_value = $r[1];
  $css_unit = $r[2];

  // font size
  if ($css_unit == "cm") {
    return round($css_value / 2.54 * 144);
  }
  if ($css_unit == "in") {
    return round($css_value * 144);
  }
  if ($css_unit == "mm") {
    return  round($css_value / 2.54 * 14.4);
  }
  if ($css_unit == "pt") {
    return round($css_value * 2);
  } 
  if ($css_unit == "px") {
    return round($css_value * 1.5);
  }
  if ($css_unit == "pc") {
    return round($css_value * 24);
  }
  
  return 24;
}
