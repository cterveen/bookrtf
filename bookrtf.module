<?php
 
 /**
 * @file
 * A  module that exports books as rtf
 */
 
 /**
 * Load the PHP simple HTML DOM parser if not done yet
 * Somehow include_once does not work as I expect, check whether function
 * str_get_html exist. This might potentially break if someone else uses
 * the same function name.
 *
 * get it here: https://simplehtmldom.sourceforge.io/
 */
if (!function_exists("str_get_html")) {
  include("simple_html_dom.php");
}
 
 /**
 * Implements hook_help().
 *
 * Displays help and module information.
 *
 * @param path 
 *   Which path of the site we're using to display help
 * @param arg 
 *   Array that holds the current path as returned from arg() function
 */
 
function bookrtf_help($path, $arg) {
  switch ($path) {
    case "admin/help#bookrtf":
      return '' . t("Exports a book as rtf file.") . '';
      break;
  }
}

/**
* Implements hook_menu().
*/

function bookrtf_menu() {
  $items = array();
  $items['book/rtf/1'] = array(
     'title' => 'Download',
     'page callback' => '_bookrtf_page',
     'page arguments' => array(2),
     'access arguments' => array('access content'),
     'type' => MENU_CALLBACK,
   );
   return $items;
}

 /**
 * Get the contents from print and, convert to RTF, save as file and show a download page.
 */

function _bookrtf_page($nid) {
  if (user_access('access content')) {
    $node = node_load($nid);
    if (isset($node->book)) {
      
      global $base_url;
      
      $tree = book_menu_subtree_data($node->book);        
      $content = bookrtf_index_traverse($tree);
      
      $file = file_destination("public://gele-boekje.rtf", FILE_EXISTS_REPLACE);
      $url_rtf = file_create_url("public://gele-boekje.rtf");
      $url_pdf = file_create_url("public://gele-boekje.pdf");
      
      $content = bookrtf_convert($content, $base_url);
      
      file_put_contents($file, $content);
      
      $page_array['index'] = array(
        '#title' => t('Download'),
        '#markup' => t('<p>Hieronder kan het Gele Boekje worden gedownload voor offline gebruik of om uit te printen. De bestanden zijn automatisch gegenereerd vanuit de tekst zoals die op de website staat.</p><p>Het gele boekje is beschikbaar in twee versies:</p><ul><li><a href = "'. $url_pdf . '">Recente PDF</a><li><a href = "' . $url_rtf . '">Actuele RTF</a></ul><p><b>Over het RTF document</b><br>De RTF-output is experimenteel. Het bestand kan geopend worden met de meeste tekstverwerkers en lijkt goed te werken in Microsoft Word en Libreoffice Writer. Mochten er fouten optreden dan kunnen deze gemeld worden bij de internetcie.</p>
        <p>Bij het genereren van het bestand wordt er niet gekeken naar de opmaak. Alinea\'s en tabellen kunnen echter vreemd worden afgebroken en afbeeldingen zijn niet altijd logisch geplaatst.</p>
        <p>In Microsoft Word worden paginanummers niet standaard weergegeven. Ga naar "Afdrukken" of "Afdrukvoorbeeld" en de paginanummers verschijnen in de inhoudsopgave en de index. Mogelijk staat overal een 1, ga dan terug naar het document en nogmaals naar "Afdrukken" of "Afdrukvoorbeeld", dan zouden de nummers goed moeten staan.'),
      );
   
      return $page_array;
    }
    else {
      drupal_not_found();
    }
  }
  else {
    drupal_access_denied();
  }  
}

 /**
 * Copy of book_index_traverse
 */

function bookrtf_index_traverse($tree) {
    $output = '';    
    
    foreach ($tree as $data) {
      // Note- access checking is already performed when building the tree.
      if ($node = node_load($data['link']['nid'], FALSE)) {
        $children = '';

        if ($data['below']) {
          $children = bookrtf_index_traverse($data['below']);
        }
      }
      
      $output .= book_node_export($node, $children);      
      
    }
    
    return $output;  
}

 /**
 * The engine, convert HTML output to RTF and add some shiny touches.
 */

function bookrtf_convert($content, $base_url) {
  // put some html tags around it so we can push it into the html converter.
  $content = "<html><body>" . $content . "</body></html>";
  
  // CLEAN UP spaces after newlines.
  $content = preg_replace("|\s+([\r\n]+)\s+|", "$1", $content);
  
  
  // Setup the parser
  $html = str_get_html($content);
    
  /**
   * HEADER
   * - Front page
   * - Flyleaf containing URL and date of download
   * - Table of contents
   * - Start of first page
   */   
   
  $header = "\\rtf1\\ansi\r\n";
  $header .= "\\deff0 {\\fonttbl {\\f0 Calibri;}}\r\n";
  $header .= "\\vertdoc\\paperh16834\\paperw11909\r\n";
  $header .= "\\fet0\\facingp\\ftnbj\\ftnrstpg\r\n";
  $header .= "\\plain\r\n";
  
  // preparing to make this a form element
  $front_page = "<html><body><h3>Gele Boekje</h3><br><br><br><img src=\"" . file_create_url("public://logo.png") . "\" /></body></html>";
  $title_html = str_get_html($front_page);
  $elements = $title_html->find('html');
  bookrtf_traverse($elements, $base_url);
  $title_html = strip_tags($title_html);
  $header .= $title_html;

  // flyleaf
  $toc = $html->find("h1");
  $book_title_element = array_shift($toc);
  $book_title = $book_title_element->innertext;
  $book_title_element->outertext = "";
    
  $date = new DateTime();
  $header .= "\\par\r\n";
  $header .= "\\sect\r\n";
  $header .= "\r\n{\\pard\\qc";
  $header .= "{\\b " . $book_title . "}\\line\r\n";
  $header .= "R&ZV Daventria\\line\r\n\\line\r\n";
  if (isset($base_url)) {
    $header .= $base_url;
  }
  else {
    $header .= "http://gele-boekje.daventria.com/";
  }
  $header .= "\\line\r\n\\line\r\n";
  $header .= "Gegenereerd: " . date_format($date, "d-m-Y") . " \\par}";
  $header .= "\\page\r\n";
  $header .= "{\\pard \\sa200 \\fs32 {\\b Inhoud}\\fs24\r\n";
  $header .= "\\par}\r\n{\\pard {";
    
  foreach ($toc as $e) {
    // Assume title starts with the chapternumber
    $title = $e->innertext;
    preg_match("|^(\d+)\.\s|", $title, $match);
    $chapter = $match[1];
    
    $header .= "\\trowd";
    $header .= "\\cellx7000 \\cellx8309\r\n"; 
    $header .= "\\intbl\\pard " .$title . "\\cell";
    $header .= "\\qr{\\field{\*\\fldinst PAGEREF chapter".$chapter."}}\\cell\\row\r\n";
  }
  
  $header .= "\\trowd";
  $header .= "\\cellx7000 \\cellx8309\r\n"; 
  $header .= "\\intbl\\pard Index\\cell";
  $header .= "\\qr{\\field{\*\\fldinst PAGEREF chapterIndex}}\\cell\\row\r\n";
  $header .= "}\\par}\r\n";
  
  /**
   *Footer
   * - index
   */
  
  $footer = "\r\n\\page\r\n\\sect\r\n";
  $footer .= "{\\headerl\\pard\\ql {\b Gele boekje}\\par}\r\n";
  $footer .= "{\\headerr\\pard\\qr Index\\par}\r\n";
  $footer .= "{\\footerr\\pard\\qr \\chpgn \\par}\r\n";
  $footer .= "{\\footerl\\pard\\ql \\chpgn \\par}\r\n";
  $footer .= "{\\pard{\\b\\fs32 ";
  $footer .= "{\\*\\bkmkstart chapterIndex}{\\*\\bkmkend chapterIndex}Index";
  $footer .= "}\\par}\r\n";
  $footer .= "\\sect \\sbknone \\cols2\r\n";  
  
  $anchors = $html->find('a[name]');
  $terms = array();
  foreach ($anchors as $a) {
    $label = $a->name;
    if (preg_match("|^index|", $label)) {
      $label = substr($label, 5);
      array_push($terms, $label);
    }
  }
  sort($terms);
  
  $cur_initial = "";
  
  global $index_id;
  $index_id = array();
  $i = 0;
  
  foreach ($terms as $t) {
    if (!isset($index_id[$t])) {
      $index_id[$t] = $i;
      $anchor = "index-" . $i ; 
      $i++;
  
      $initial = substr($t, 0, 1);
      if (is_numeric($initial)) {
        $initial = "#";
      }
      if ($initial != $cur_initial) {
        if ($cur_initial != "") {
          $footer .= "\\par}\r\n";
        }
        $footer .= "{\\pard\\fs28{\\b " . $initial . "\\b}\\par}\r\n";
        $footer .= "{\\pard\\ql ";
        $cur_initial = $initial;
      }
      $footer .= $t . " {\\field{\*\\fldinst PAGEREF ".$anchor."}}\\line\r\n";
    }
  }
  $footer .= "\\par}\r\n";
  
  /** 
  * Start changing the content from HTML into RTF
  * The tough work is going to be done by bookrtf_traverse. 
  */
  $elements = $html->find('html');
  bookrtf_traverse($elements, $base_url);  
  
  // strip all remaining tags
  $html = strip_tags($html);
  
  // dumb the new code back to $content
  $content = $html;
  
  // FINAL DOCUMENT
  $content = "{" . $header . "\r\n" . $content . "\r\n" . $footer . "}";
  
  // the HTML parser adds some spaces which doesn't matter in HTML but does in RTF
  $content = preg_replace("|\s+([\r\n]+)\s+|", "$1", $content);
  $content = preg_replace("|\\intbl{\s+{|", "intbl{{", $content);
  
  // SPECIAL CHARACTERS
  // extended ascii
  $content = preg_replace("|€|", "\'80", $content);
  // $content = preg_replace("|foo|", "\'81", $content);
  $content = preg_replace("|‚|", "\'82", $content);
  $content = preg_replace("|ƒ|", "\'83", $content);
  $content = preg_replace("|„|", "\'84", $content);
  $content = preg_replace("|…|", "\'85", $content);
  $content = preg_replace("|†|", "\'86", $content);
  $content = preg_replace("|‡|", "\'87", $content);
  $content = preg_replace("|ˆ|", "\'88", $content);
  $content = preg_replace("|‰|", "\'89", $content);
  $content = preg_replace("|Š|", "\'8a", $content);
  $content = preg_replace("|‹|", "\'8b", $content);
  $content = preg_replace("|Œ|", "\'8c", $content);
  // $content = preg_replace("|foo|", "\'8d", $content);
  $content = preg_replace("|Ž|", "\'8e", $content);
  // $content = preg_replace("|foo|", "\'8f", $content);
  $content = preg_replace("|‘|", "\'91", $content);
  $content = preg_replace("|’|", "\'92", $content);
  $content = preg_replace("|´|", "\'b4", $content);
  $content = preg_replace("|“|", "\'93", $content);
  $content = preg_replace("|”|", "\'94", $content);
  $content = preg_replace("|•|", "\'95", $content);
  $content = preg_replace("|–|", "\'96", $content);
  $content = preg_replace("|–|", "\'97", $content);
  $content = preg_replace("|˜|", "\'98", $content);
  $content = preg_replace("|™|", "\'99", $content);
  $content = preg_replace("|š|", "\'9a", $content);
  $content = preg_replace("|›|", "\'9b", $content);
  $content = preg_replace("|œ|", "\'9c", $content);
  // $content = preg_replace("|foo|", "\'9d", $content);
  $content = preg_replace("|ž|", "\'9e", $content);
  $content = preg_replace("|Ÿ|", "\'9f", $content);
  // $content = preg_replace("|foo|", "\'a0", $content);
  $content = preg_replace("|¡|", "\'a1", $content);
  $content = preg_replace("|¢|", "\'a2", $content);
  $content = preg_replace("|£|", "\'a3", $content);
  $content = preg_replace("|¤|", "\'a4", $content);
  $content = preg_replace("|¥|", "\'a5", $content);
  $content = preg_replace("|¦|", "\'a6", $content);
  $content = preg_replace("|§|", "\'a7", $content);
  $content = preg_replace("|¨|", "\'a8", $content);
  $content = preg_replace("|©|", "\'a9", $content);
  $content = preg_replace("|ª|", "\'aa", $content);
  $content = preg_replace("|«|", "\'ab", $content);
  $content = preg_replace("|¬|", "\'ac", $content);
  // $content = preg_replace("|foo|", "\'ad", $content); // Should be soft hyphen
  $content = preg_replace("|®|", "\'ae", $content);
  $content = preg_replace("|¯|", "\'af", $content);
  $content = preg_replace("|°|", "\'b0", $content);
  $content = preg_replace("|±|", "\'b1", $content);
  $content = preg_replace("|²|", "\'b2", $content);
  $content = preg_replace("|³|", "\'b3", $content);
  $content = preg_replace("|´|", "\'b4", $content);
  $content = preg_replace("|µ|", "\'b5", $content);
  $content = preg_replace("|¶|", "\'b6", $content);
  $content = preg_replace("|·|", "\'b7", $content);
  $content = preg_replace("|¸|", "\'b8", $content);
  $content = preg_replace("|¹|", "\'b9", $content);
  $content = preg_replace("|º|", "\'ba", $content);
  $content = preg_replace("|»|", "\'bb", $content);
  $content = preg_replace("|¼|", "\'bc", $content);
  $content = preg_replace("|½|", "\'bd", $content);
  $content = preg_replace("|¾|", "\'be", $content);
  $content = preg_replace("|¿|", "\'bf", $content);
  $content = preg_replace("|À|", "\'c0", $content);
  $content = preg_replace("|Á|", "\'c1", $content);
  $content = preg_replace("|Â|", "\'c2", $content);
  $content = preg_replace("|Ã|", "\'c3", $content);
  $content = preg_replace("|Ä|", "\'c4", $content);
  $content = preg_replace("|Å|", "\'c5", $content);
  $content = preg_replace("|Æ|", "\'c6", $content);
  $content = preg_replace("|Ç|", "\'c7", $content);
  $content = preg_replace("|È|", "\'c8", $content);
  $content = preg_replace("|É|", "\'c9", $content);
  $content = preg_replace("|Ê|", "\'ca", $content);
  $content = preg_replace("|Ë|", "\'cb", $content);
  $content = preg_replace("|Ì|", "\'cc", $content);
  $content = preg_replace("|Í|", "\'cd", $content);
  $content = preg_replace("|Î|", "\'ce", $content);
  $content = preg_replace("|Ï|", "\'cf", $content);
  $content = preg_replace("|Ð|", "\'d0", $content);
  $content = preg_replace("|Ñ|", "\'d1", $content);
  $content = preg_replace("|Ò|", "\'d2", $content);
  $content = preg_replace("|Ó|", "\'d3", $content);
  $content = preg_replace("|Ô|", "\'d4", $content);
  $content = preg_replace("|Õ|", "\'d5", $content);
  $content = preg_replace("|Ö|", "\'d6", $content);
  $content = preg_replace("|×|", "\'d7", $content);
  $content = preg_replace("|Ø|", "\'d8", $content);
  $content = preg_replace("|Ù|", "\'d9", $content);
  $content = preg_replace("|Ú|", "\'da", $content);
  $content = preg_replace("|Û|", "\'db", $content);
  $content = preg_replace("|Ü|", "\'dc", $content);
  $content = preg_replace("|Ý|", "\'dd", $content);
  $content = preg_replace("|Þ|", "\'de", $content);
  $content = preg_replace("|ß|", "\'df", $content);
  $content = preg_replace("|à|", "\'e0", $content);
  $content = preg_replace("|á|", "\'e1", $content);
  $content = preg_replace("|â|", "\'e2", $content);
  $content = preg_replace("|ã|", "\'e3", $content);
  $content = preg_replace("|ä|", "\'e4", $content);
  $content = preg_replace("|å|", "\'e5", $content);
  $content = preg_replace("|æ|", "\'e6", $content);
  $content = preg_replace("|ç|", "\'e7", $content);
  $content = preg_replace("|è|", "\'e8", $content);
  $content = preg_replace("|é|", "\'e9", $content);
  $content = preg_replace("|ê|", "\'ea", $content);
  $content = preg_replace("|ë|", "\'eb", $content);
  $content = preg_replace("|ì|", "\'ec", $content);
  $content = preg_replace("|í|", "\'ed", $content);
  $content = preg_replace("|î|", "\'ee", $content);
  $content = preg_replace("|ï|", "\'ef", $content);
  $content = preg_replace("|ð|", "\'f0", $content);
  $content = preg_replace("|ñ|", "\'f1", $content);
  $content = preg_replace("|ò|", "\'f2", $content);
  $content = preg_replace("|ó|", "\'f3", $content);
  $content = preg_replace("|ô|", "\'f4", $content);
  $content = preg_replace("|õ|", "\'f5", $content);
  $content = preg_replace("|ö|", "\'f6", $content);
  $content = preg_replace("|÷|", "\'f7", $content);
  $content = preg_replace("|ø|", "\'f8", $content);
  $content = preg_replace("|ù|", "\'f9", $content);
  $content = preg_replace("|ú|", "\'fa", $content);
  $content = preg_replace("|û|", "\'fb", $content);
  $content = preg_replace("|ü|", "\'fc", $content);
  $content = preg_replace("|ý|", "\'fd", $content);
  $content = preg_replace("|þ|", "\'fe", $content);
  $content = preg_replace("|ÿ|", "\'ff", $content);

  // html
  $content = preg_replace("|&amp;|", "&", $content);
  $content = preg_replace("|&deg;|", "\'b0", $content);
  $content = preg_replace("|&gt;|", ">", $content);
  $content = preg_replace("|&lt;|", "<", $content);
  $content = preg_replace("|&nbsp;|", " ", $content);
  $content = preg_replace("|&#039;|", "'", $content);

  // non breaking space
  $content = preg_replace("|\x{C2}\x{A0}|", " ", $content);

  return $content;
}

/**
 * HTML parsers may not spawn demons but if you use them to replace HTML tags
 * by RTF code they do attract gremlins as the parser gets in trouble with
 * nested tags (which occur a lot in HTML). Probably the parser is losing it's
 * structure. This is solved by going through the tree and start replacing tags
 * at the branches working up to the main stem.
 *
 * @param elements 
 *   the basic $elements from which to start
 * @param base_url 
 *   The base URL of the site, needed to convert links.
 */
 
function bookrtf_traverse ($elements, $base_url) {
  foreach ($elements as $e) {
    if ($e->first_child()) {
      $children = $e->children();
      bookrtf_traverse($children, $base_url);
    }
    
    // no children anymore --> start changing tags
    $tag = $e->tag;
    
    switch($tag) {
      case 'a':
        // this could be either external links or anchors
        if ($e->href) {
          // external link --> replace with footnote
          $url = $e->href;
          $title = $e->innertext;
          
          // no use to add a footnote if the link and label are the same
          if (preg_match("|^(https?://)?(mailto:)?" . $title . "/?$|", $url)) {
            $e->outertext = $title;
          }
          else {
            $e->outertext = $title . "{\\footnote \\pard {\\up6 \\chftn} " . $url . "}"; 
          }          
        }
        else if ($e->name) {
         if (preg_match("|^index|", $e->name)) {
           $label = substr($e->name, 5);
           global $index_id;
           $anchor = "index-" . $index_id[$label]; 
           $e->outertext = "{\\*\\bkmkstart ".$anchor."}{\\*\\bkmkend ".$anchor."}";
          }
        }
        break;
      case 'br':
        $e->outertext = "\\tab\\line\r\n";
        break;
      case 'h1':
        // start of a new chapter --> new page, right header contains chapter title, bookmark for the table of contents
        $title = $e->innertext;
                
        $rtf = "\\sect\\sftnrstpg\r\n";
        $rtf .= "{\\headerl\\pard\\ql {\\b Gele boekje}\\par}\r\n";
        $rtf .= "{\\headerr\\pard\\qr " . $title . "}\r\n";
        $rtf .= "{\\footerr\\pard\\qr \\chpgn \\par}\r\n";
        $rtf .= "{\\footerl\\pard\\ql \\chpgn \\par}\r\n";
        // if the chapter starts with a number it should be in the index, add a bookmark for it
        if (preg_match("|^(\d+)\.\s|", $title, $match)) {
          $chapter = $match[1];
          $rtf .= "{\\*\\bkmkstart chapter".$chapter."}{\\*\\bkmkend chapter".$chapter."}\r\n";
        }
        $rtf .= "{\\pard{\\b\\fs32 " . $title . "}\\par}\r\n";
        
        $e->outertext = $rtf;
        break;
      case 'h2':
        $e->outertext = "{\\pard\\sa0{\\b\\fs28 " . $e->innertext . "}\\par}\r\n";
        break;
      case 'h3': 
        $e->outertext = "{\\pard\\sa0\\qc{\\b\\fs32 " . $e->innertext . "}\\par}\r\n";     
        break;
      case 'i': 
        $e->outertext = "{\\i " . $e->innertext . "}";
        break;
      case 'img':
        $url = $e->src;
        
        // assume relative url
        if (isset($base_url) & substr($url, 0, 4) != "http") {
          $url = $base_url . $url;
        }
        
        $string = file_get_contents($url);
        
        $img = imagecreatefromstring($string);
        
        $width = imagesx($img);
        $height = imagesy($img);
        $ratio = $width/$height;
        
        // asume full page width A4 - margins = 9028 - XX  = 8309 twips
        $picwidth = 8309;
        $picheight = round($picwidth / $ratio);
        $scalex = 100;
        $scaley = 100;

        $rtf = "{\\pard{\\pict\\picw".$width."\\pich".$height."\\picwgoal".$picwidth."\\pichgoal".$picheight."\\picscalex".$scalex."\\picscaley".$scaley;
    
        // set image type (jpg or png supported)
        if (substr($url, -4) == ".png") {
          $rtf .= "\pngblip\r\n";
        }
        else if (substr($url, -4) == ".jpg" or substr($url, -5) == ".jpeg") {
          $rtf .= "\jpegblip\r\n";
        }

        $hex = bin2hex($string);
        $hex = wordwrap($hex, 80, "\r\n", TRUE);
        
        $rtf .= $hex;
        $rtf .= "\r\n}\\par}\r\n";
        
        $e->outertext = $rtf;
        break;
      case 'li':
        /**
         * This might be a bit dirty but as I'm not going to make elaborate
         * list structures I feel confident working from li backwards and
         * strip out the list-tags later.
         */
         
        $level = 0;
        $type = "ul";
        $number = 1;
        $last = 1;
        
        // Type, level
        $p = $e->parent();
        while($p) {
          if ($p->tag == "ul" | $p->tag == "ol") {
            if ($level == 0) {
              $type = $p->tag;
            }
            $level++;
          }
          $p = $p->parent();
        }
        // Item number
        $s = $e->prev_sibling();
        while($s) {
          if ($s->tag == "li") {
            $number++;
          }
          $s = $s->prev_sibling();
        }
        // Last item?
        $s = $e->next_sibling();
        while($s) {
          if ($s->tag == "li") {
            $last = 0;
            break;
          }
          $s = $s->next_sibling();
        }
        
        $rtf = "";
        // if the first item of a nested list close the current paragraph.
        // TODO: might want to check if the list is inside a paragraph and do that anyway
        if ($level > 1 & $number == 1) {
          $rtf .= "\\par}\r\n";
        }
        $rtf .= "{\\pard";
        
        $firstindent = -360;
        $lineindent = 720 * $level;
        
        $rtf .= "\\fi" . $firstindent . "\\li". $lineindent;
        if ($type == "ul") {
          $rtf .= "\\bullet\\tab ";
        }
        else {
          $rtf .= " " . $array['id'] . ".\\tab ";
        }
        $rtf .= $e->innertext;
        
         // finish the paragraph unless it's the last item in a nested list
        // TODO this will give trouble if there's tekst after the nested list. This text will be included in the last item of the nested list at the moment.        
        if ($last != 1 | $level == 1) {
          $rtf .= "\\par}\r\n";
        }
        
        // if it's the last item of the list add some white space
        // TODO this creates an empty line, would be nicer if I could make that 200 twips height.
        if ($last == 1 & $level == 1) {
          $rtf .= "{\\pard\\sa0\\par}\r\n";
        }

        $e->outertext = $rtf;
        break;
      case 'p':
        $e->outertext = "{\\pard\\sa200\\qj " . $e->innertext . "\\par}\r\n";
        break;
      case 'strong': 
        $e->outertext = "{\\b " . $e->innertext . "}";
        break;
      case 'sub':
        $e->outertext = "{\\sub " . $e->innertext . "}";
        break;
      case 'sup': 
        $e->outertext = "{\\super " . $e->innertext . "}";
        break;
      case 'tbody':
        /**
         * Tables are a little bit more complicated than lists. I do not feel
         * confident working backwards from cells. Better to store the whole
         * table and than put it down again.
         */
         
        $width_in_twips = 8309;
        $width_in_pixels = 600;
        $num_rows = 0;
        $num_cols = 0;
        $table;
        $colwidth = array();        

        // retrieve table contents and some required specifications
        $rows = $e->children();
        foreach ($rows as $r) {
          if ($r->tag != "tr") {
            continue;
          }
          $num_rows++;
          $cells = $r->children();
          $cur_cols = 0;
          foreach ($cells as $c) {
            if ($c->tag != 'td' & $c->tag != 'th') {
              continue;
            }
            $cur_cols++;
            $table[$num_rows][$cur_cols]['innertext'] = $c->innertext;
            $table[$num_rows][$cur_cols]['col'] = $cur_cols;
            if ($c->colspan) {
              $table[$num_rows][$cur_cols]['colspan'] = $c->colspan;
            }
            else {
              $table[$num_rows][$cur_cols]['colspan'] = 1;
            }
            
            // Does using regexp for css also spawn demons?
            if ($c->style) {
              $style = array();
              preg_match_all("/([\w\-]+):\s([\w\s\-]+);?/", $c->style, $matches);
              
              for ($pid = 0; $pid < count($matches[0]); $pid++) {
                $style[$matches[1][$pid]] = $matches[2][$pid];
              }
              
              if(array_key_exists("width", $style)) {
                // asume width in pixels -> make percentage.
                if (substr($style['width'], -2) == "px") {
                  $width = substr($style['width'], 0, -2);
                  $colwidth[$cur_cols] = $width / $width_in_pixels;
                }                
              }
            }
            
            // correct cur_cols for colspan.
            $cur_cols += $table[$num_rows][$cur_cols]['colspan']-1;
          }
          if ($cur_cols > $num_cols) {
            $num_cols = $cur_cols;
          }
        }
        
        // some complicated stuff to calculate column widths
        $colright = array();
        $widthdefined = 0;
        $auto = 0;
        for ($col = 1; $col <= $num_cols; $col++) {
          if (array_key_exists($col, $colwidth)) {
            $widthdefined += $colwidth[$col];
          }
          else {
            $auto++;
          }
        }
        $autowidth = (1 - $widthdefined)/$auto;
        
        $colleft = 0;
        for ($col = 1; $col <= $num_cols; $col++) {
          if (array_key_exists($col, $colwidth)) {
            $colleft += $colwidth[$col];
          }
          else {
            $colleft += $autowidth;
          }
          $colright[$col] = $colleft;
        }
        
        // now we have the info start building it up again
        $rtf = "{";
        foreach ($table as $row) {
          $rtf .= "\\trowd";
          foreach ($row as $cell) {
            $rtf .= "\\cellx";
            $rtf .= floor($width_in_twips * $colright[$cell['col']+$cell['colspan']-1]);
          }
          foreach ($row as $cell) {
            $rtf .= "\\intbl{" . $cell['innertext'] . "}\\cell\r\n";
          }
          $rtf .= "\\row\r\n";
        }
        $rtf .= "}\r\n{\\pard\\par}\r\n";
          
        $e->outertext = $rtf;
        break;
      case 'title':
        $e->outertext = "";
        break;
      case 'u':
        $e->outertext = "{\\ul " . $e->innertext . "}";
    }    
  }
}
